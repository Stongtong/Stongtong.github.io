<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HBASE中的数据刷写]]></title>
    <url>%2F2019%2F02%2F17%2FHBASE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%B7%E5%86%99%2F</url>
    <content type="text"><![CDATA[摘要：由于HBASE中使用LSM，所以在HBASE中插入数据时，是批量从内存中flush到磁盘（HDFS），本文介绍总结HBASE中触发flush动作的详细条件，从而对flush过程进行优化。（本文参考自HBASE社区文章） 写数据过程简介HBASE数据写入都是先将数据写入内存，在内存中存在memstore的结构（在写入内存之前会先通过wal进行日志的备份，相信大家都知道这个），memstore中的数据最终会持久化到磁盘，持久化的原理就是之前文章说的LSM数据结构（内存树与磁盘树的合并），最终在磁盘上以hfile的方式进行存储，这里附HBASE的一张整体结构图，该图较为清晰的对memstore、hfile以及其他HBASE的概念的关系进行说明。 理解 MemStore 的刷写对优化 MemStore 有很重要的意义，大部分人遇到的性能问题都是写操作被阻塞(Block)无法写入HBase。本文基于 HBase 2.0.2，并对 MemStore 的 Flush 进行说明，包括哪几种条件触发 Memstore Flush 和目前常见的刷写策略(FlushPolicy)。 触发Flush条件有很多情况会触发 MemStore 的 Flush 操作，所以我们最好需要了解每种情况在什么时候触发 Memstore Flush。总的来说，主要有以下几种情况会触发 Memstore Flush： Region中所有MemStore占用的内存超过阈值范围 整个RegionServer的MemStore占用内存总和大于相关阈值 WAL数量大于相关阈值 定期自动刷写 数据更新超过一定阈值 手动触发刷写 下面对如上集中情况进行详细说明。 Region中所有memstore占用内存超过阈值当一个 Region 中所有 MemStore 占用的内存(包括 OnHeap + OffHeap)大小超过刷写阈值的时候会触发一次刷写，这个阈值由 hbase.hregion.memstore.flush.size 参数控制，默认为128MB。我们每次调用 put、delete 等操作都会检查的这个条件的。 但是如果我们的数据增加得很快，达到 hbase.hregion.memstore.flush.size * hbase.hregion.memstore.block.multiplier 的大小，hbase.hregion.memstore.block.multiplier 默认值为4，也就是128*4=512MB的时候，那么除了触发 MemStore 刷写之外，HBase 还会在刷写的时候同时阻塞所有写入该 Store 的写请求（这是因为写入速率太快，如果不限制写入数据的请求，很可能导致HBASE内存空间被占满的情况）！这时候如果你往对应的 Store 写数据，会出现 RegionTooBusyException 异常。 RegionServer 的 MemStore 占用内存总和大于相关阈值HBase 为 RegionServer 的 MemStore 分配一定的写缓存，大小等于 hbase_heapsize(RegionServer占用的堆内存大小)* hbase.regionserver.global.memstore.size。hbase.regionserver.global.memstore.size 的默认值是 0.4，也就是说写缓存大概占用 RegionServer 整个 JVM 内存使用量的 40%。 如果整个 RegionServer 的 MemStore 占用内存总和大于 hbase.regionserver.global.memstore.size.lower.limit * hbase.regionserver.global.memstore.size * hbase_heapsize 的时候，将会触发 MemStore 的刷写。其中 hbase.regionserver.global.memstore.size.lower.limit 的默认值为 0.95。 举个例子，如果我们 HBase 堆内存总共是 32G，按照默认的比例，那么触发 RegionServer 级别的 Flush 是 RegionServer 中所有的 MemStore 占用内存为：32 0.4 0.95 = 12.16G。 注意：0.99.0 之前 hbase.regionserver.global.memstore.size 是 hbase.regionserver.global.memstore.upperLimit 参数；hbase.regionserver.global.memstore.size.lower.limit 是 hbase.regionserver.global.memstore.lowerLimit，参见 HBASE-5349 RegionServer 级别的 Flush 策略是每次找到 RS 中占用内存最大的 Region 对它进行刷写，这个操作是循环进行的，直到总体内存的占用低于全局 MemStore 刷写下限(hbase.regionserver.global.memstore.size.lower.limit * hbase.regionserver.global.memstore.size * hbase_heapsize)才会停止。 需要注意的是，如果达到了 RegionServer 级别的 Flush，那么当前 RegionServer 的所有写操作将会被阻塞，而且这个阻塞可能会持续到分钟级别。（敏感的人已经发现在这应该尽量避免RegionServer级别的flush） WAL数量大于相关阈值WAL(write-ahead log，预写日志)用来解决宕机之后的操作恢复问题的。数据到达 Region 的时候是先写入 WAL，然后再被写到 Memstore 的。如果 WAL 的数量越来越大，这就意味着 MemStore 中未持久化到磁盘的数据越来越多。当 RS 挂掉的时候，恢复时间将会变长，所以有必要在 WAL 到达一定的数量时进行一次刷写操作。阈值 maxLogs 的计算公式如下： 1234567891011121314151617181920212223242526272829303132// Schedule a WAL roll when the WAL is 50% of the HDFS block size. Scheduling at 50% of block// size should make it so WAL rolls before we get to the end-of-block (Block transitions cost// some latency). In hbase-1 we did this differently. We scheduled a roll when we hit 95% of// the block size but experience from the field has it that this was not enough time for the// roll to happen before end-of-block. So the new accounting makes WALs of about the same// size as those made in hbase-1 (to prevent surprise), we now have default block size as// 2 times the DFS default: i.e. 2 * DFS default block size rolling at 50% full will generally// make similar size logs to 1 * DFS default block size rolling at 95% full. See HBASE-19148.this.blocksize = WALUtil.getWALBlockSize(this.conf, this.fs, this.walDir);float multiplier = conf.getFloat("hbase.regionserver.logroll.multiplier", 0.5f);this.logrollsize = (long)(this.blocksize * multiplier);this.maxLogs = conf.getInt("hbase.regionserver.maxlogs", Math.max(32, calculateMaxLogFiles(conf, logrollsize)));/** * Public because of FSHLog. Should be package-private * @param isRecoverEdits the created writer is for recovered edits or WAL. * For recovered edits, it is true and for WAL it is false. */public static long getWALBlockSize(Configuration conf, FileSystem fs, Path dir, boolean isRecoverEdits) throws IOException &#123; long defaultBlockSize = CommonFSUtils.getDefaultBlockSize(fs, dir) * 2; if (isRecoverEdits) &#123; return conf.getLong("hbase.regionserver.recoverededits.blocksize", defaultBlockSize); &#125; return conf.getLong("hbase.regionserver.hlog.blocksize", defaultBlockSize);&#125;private int calculateMaxLogFiles(Configuration conf, long logRollSize) &#123; Pair&lt;Long, MemoryType&gt; globalMemstoreSize = MemorySizeUtil.getGlobalMemStoreSize(conf); return (int) ((globalMemstoreSize.getFirst() * 2) / logRollSize);&#125; 也就是说，如果设置 hbase.regionserver.maxlogs，那就是这个参数的值；否则是 max(32, hbase_heapsize * hbase.regionserver.global.memstore.size * 2 / logRollSize)。如果某个 RegionServer 的 WAL 数量大于 maxLogs 就会触发 MemStore 的刷写。 WAL 数量触发的刷写策略是，找到最旧的 un-archived WAL 文件，并找到这个 WAL 文件对应的 Regions， 然后对这些 Regions 进行刷写。 定期自动刷写如果我们很久没有对 HBase 的数据进行更新，这时候就可以依赖定期刷写策略了。RegionServer 在启动的时候会启动一个线程 PeriodicMemStoreFlusher 每隔 hbase.server.thread.wakefrequency 时间检查属于这个 RegionServer 的 Region 有没有超过一定时间都没有刷写，这个时间是由 hbase.regionserver.optionalcacheflushinterval 参数控制的，默认是 3600000，单位ms，也就是1小时会进行一次刷写。如果设定为0，则意味着关闭定时自动刷写。 为了防止一次性有过多的 MemStore 刷写，定期自动刷写会有 0 ~ 5 分钟的延迟，具体参见 PeriodicMemStoreFlusher 类的实现。 数据更新超过一定阈值如果 HBase 的某个 Region 更新的很频繁，而且既没有达到自动刷写阀值，也没有达到内存的使用限制，但是内存中的更新数量已经足够多，比如超过 hbase.regionserver.flush.per.changes 参数配置，默认为30000000，那么也是会触发刷写的。 手动触发刷写除了 HBase 内部一些条件触发的刷写之外，我们还可以通过执行相关命令或 API 来触发 MemStore 的刷写操作。比如调用可以调用 Admin 接口提供的方法： 12345678910111213141516171819202122/** * Flush a table. Synchronous operation. * * @param tableName table to flush * @throws IOException if a remote or network exception occurs */void flush(TableName tableName) throws IOException;/** * Flush an individual region. Synchronous operation. * * @param regionName region to flush * @throws IOException if a remote or network exception occurs */void flushRegion(byte[] regionName) throws IOException;/** * Flush all regions on the region server. Synchronous operation. * @param serverName the region server name to flush * @throws IOException if a remote or network exception occurs */void flushRegionServer(ServerName serverName) throws IOException; 分别对某张表、某个 Region 或者某个 RegionServer 进行刷写操作。也可以在 Shell 中通过执行 flush 命令： 1234hbase&gt; flush &apos;TABLENAME&apos;hbase&gt; flush &apos;REGIONNAME&apos;hbase&gt; flush &apos;ENCODED_REGIONNAME&apos;hbase&gt; flush &apos;REGION_SERVER_NAME&apos; 需要注意的是，以上所有条件触发的刷写操作最后都会检查对应的 HStore 包含的 StoreFiles 文件超过 hbase.hstore.blockingStoreFiles 参数配置的个数，默认值是16。如果满足这个条件，那么当前刷写会被推迟到 hbase.hstore.blockingWaitTime 参数设置的时间后再刷写。在阻塞刷写的同时，HBase 还会请求 Split 或 Compaction 操作。（在flush之前，先对region进行分离或者合并操作） 哪些操作触发 MemStore Flush我们常见的 put、delete、append、increment、调用 flush 命令、Region 分裂、Region Merge、bulkLoad HFiles 以及给表做快照操作都会对上面的相关条件做检查，以便判断要不要做刷写操作。 MemStore Flush策略(FlushPolicy)在 HBase 1.1 之前，MemStore 刷写是 Region 级别的。就是说，如果要刷写某个 MemStore ，MemStore 所在的 Region 中其他 MemStore 也是会被一起刷写的！这会造成一定的问题，比如小文件问题，具体参见 《为什么不建议在 HBase 中使用过多的列族》。针对这个问题，HBASE-10201/HBASE-3149引入列族级别的刷写。我们可以通过 hbase.regionserver.flush.policy 参数选择不同的刷写策略。 目前 HBase 2.0.2 的刷写策略全部都是实现 FlushPolicy 抽象类的。并且自带三种刷写策略：FlushAllLargeStoresPolicy、FlushNonSloppyStoresFirstPolicy 以及 FlushAllStoresPolicy。 FlushAllStoresPolicy这种刷写策略实现最简单，直接返回当前 Region 对应的所有 MemStore。也就是每次刷写都是对 Region 里面所有的 MemStore 进行的，这个行为和 HBase 1.1 之前是一样的。 FlushAllLargeStoresPolicy在 HBase 2.0 之前版本是 FlushLargeStoresPolicy，后面被拆分成分 FlushAllLargeStoresPolicy 和FlushNonSloppyStoresFirstPolicy，参见 HBASE-14920。 这种策略会先判断 Region 中每个 MemStore 的使用内存(OnHeap+OffHeap)是否大于某个阀值，大于这个阀值的 MemStore 将会被刷写。阀值的计算是由 hbase.hregion.percolumnfamilyflush.size.lower.bound 、hbase.hregion.percolumnfamilyflush.size.lower.bound.min 以及 hbase.hregion.memstore.flush.size 参数决定的。计算逻辑如下： 123456//region.getMemStoreFlushSize() / familyNumber//就是 hbase.hregion.memstore.flush.size 参数的值除以相关表列族的个数flushSizeLowerBound = max(region.getMemStoreFlushSize() / familyNumber, hbase.hregion.percolumnfamilyflush.size.lower.bound.min)//如果设置了 hbase.hregion.percolumnfamilyflush.size.lower.boundflushSizeLowerBound = hbase.hregion.percolumnfamilyflush.size.lower.bound hbase.hregion.percolumnfamilyflush.size.lower.bound.min 默认值为 16MB，而 hbase.hregion.percolumnfamilyflush.size.lower.bound 没有设置。 比如当前表有3个列族，其他用默认的值，那么 flushSizeLowerBound = max((long)128 / 3, 16) = 42。 如果当前 Region 中没有 MemStore 的使用内存大于上面的阀值，FlushAllLargeStoresPolicy 策略就退化成 FlushAllStoresPolicy 策略了，也就是会对 Region 里面所有的 MemStore 进行 Flush。 FlushNonSloppyStoresFirstPolicyHBase 2.0 引入了 in-memory compaction，参见 HBASE-13408。如果我们对相关列族 hbase.hregion.compacting.memstore.type 参数的值不是 NONE，那么这个 MemStore 的 isSloppyMemStore 值就是 true，否则就是 false。 FlushNonSloppyStoresFirstPolicy 策略将 Region 中的 MemStore 按照 isSloppyMemStore 分到两个 HashSet 里面（sloppyStores 和 regularStores）。然后 判断 regularStores 里面是否有 MemStore 内存占用大于相关阀值的 MemStore ，有的话就会对这些 MemStore 进行刷写，其他的不做处理，这个阀值计算和 FlushAllLargeStoresPolicy 的阀值计算逻辑一致。 如果 regularStores 里面没有 MemStore 内存占用大于相关阀值的 MemStore，这时候就开始在 sloppyStores 里面寻找是否有 MemStore 内存占用大于相关阀值的 MemStore，有的话就会对这些 MemStore 进行刷写，其他的不做处理。 如果上面 sloppyStores 和 regularStores 都没有满足条件的 MemStore 需要刷写，这时候就 FlushNonSloppyStoresFirstPolicy 策略久退化成 FlushAllStoresPolicy 策略了。 MemStore Flush 刷写过程MemStore 的刷写过程很复杂，很多操作都可能触发，但是这些条件触发的刷写最终都是调用 HRegion 类中的 internalFlushcache 方法。 1234567891011121314151617181920212223242526272829/** * Flush the memstore. Flushing the memstore is a little tricky. We have a lot of updates in the * memstore, all of which have also been written to the wal. We need to write those updates in the * memstore out to disk, while being able to process reads/writes as much as possible during the * flush operation. * &lt;p&gt; * This method may block for some time. Every time you call it, we up the regions sequence id even * if we don&apos;t flush; i.e. the returned region id will be at least one larger than the last edit * applied to this region. The returned id does not refer to an actual edit. The returned id can * be used for say installing a bulk loaded file just ahead of the last hfile that was the result * of this flush, etc. * @param wal Null if we&apos;re NOT to go via wal. * @param myseqid The seqid to use if &lt;code&gt;wal&lt;/code&gt; is null writing out flush file. * @param storesToFlush The list of stores to flush. * @return object describing the flush&apos;s state * @throws IOException general io exceptions * @throws DroppedSnapshotException Thrown when replay of WAL is required. */protected FlushResultImpl internalFlushcache(WAL wal, long myseqid, Collection&lt;HStore&gt; storesToFlush, MonitoredTask status, boolean writeFlushWalMarker, FlushLifeCycleTracker tracker) throws IOException &#123; PrepareFlushResult result = internalPrepareFlushCache(wal, myseqid, storesToFlush, status, writeFlushWalMarker, tracker); if (result.result == null) &#123; return internalFlushCacheAndCommit(wal, status, result, storesToFlush); &#125; else &#123; return result.result; // early exit due to failure from prepare stage &#125;&#125; 从上面的实现可以看出，Flush 操作主要分以下几步做的 prepareFlush 阶段：刷写的第一步是对 MemStore 做 snapshot，为了防止刷写过程中更新的数据同时在 snapshot 和 MemStore 中而造成后续处理的困难，所以在刷写期间需要持有 updateLock 。持有了 updateLock 之后，这将阻塞客户端的写操作。所以只在创建 snapshot 期间持有 updateLock，而且 snapshot 的创建非常快，所以此锁期间对客户的影响一般非常小。对 MemStore 做 snapshot 是 internalPrepareFlushCache 里面进行的。 flushCache 阶段：如果创建快照没问题，那么返回的 result.result 将为 null。这时候我们就可以进行下一步 internalFlushCacheAndCommit。其实 internalFlushCacheAndCommit 里面包含两个步骤：flushCache 和 commit 阶段。flushCache 阶段其实就是将 prepareFlush 阶段创建好的快照写到临时文件里面，临时文件是存放在对应 Region 文件夹下面的 .tmp 目录里面。 commit 阶段：将 flushCache 阶段生产的临时文件移到(rename)对应的列族目录下面，并做一些清理工作，比如删除第一步生成的 snapshot。 总结HBASE的使用并不是很复杂，甚至很多人认为有点简单，但是涉及到大数据量时，往往会出现很多“意想不到”的问题，这种情况下深入到数据库的实现细节，根据其原理去定向的优化数据库就很是重要的，说到底还是要在源码级别对一个东西有系统性的认识。 本文作者：tongtong本文链接：https://stongtong.github.io/版权申明：网站内容为tongtong所有，转载请注明出处。]]></content>
      <categories>
        <category>Hbase</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
        <tag>flush</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown中的绘图语法]]></title>
    <url>%2F2018%2F01%2F13%2Fmarkdown%E4%B8%AD%E7%9A%84%E7%BB%98%E5%9B%BE%E8%AF%AD%E6%B3%95-md%2F</url>
    <content type="text"><![CDATA[前言：一直在用七牛云作为博客的图床，但是之前发现在七牛云的图床网址必须要进行备案了，太委屈！我自己的个人网站，就是在写写自己的日记、技术笔记、工作感悟、巴拉巴拉巴拉，还要让我备案，真是没地说理去；辗转反侧，也不能因为这个事情不写、不记录啊，所以最近萌生了博客无图的想法，之前用markdown的时候正好接触过markdown的绘图功能，身材很好（轻量级）并且该有的都有，哈哈，今天用这篇博客记录一下markdown中的常用绘图语法，方便以后使用。 1 语法介绍markdown能够绘制的图形有很多种，例如最常见的框图、流程图、甘特图、时序图等等，这里先对其关键字进行介绍。 1.1 基本关键字 mermaid：主要用来绘制框图、甘特图、时序图等，该关键字是比较标准的用法，配合其他关键字能够完成特定图形的绘制； gantt：绘制甘特图； sequenceDiagram：绘制时序图（UML）； graph ：绘制框图时，图形的位置，后面可接收方向关键词，具体如下（比较简单，不再解释）： TB - top bottom BT - bottom top RL - right left LR - left right TD - as same TB flow：用来绘制完整的流程图； sequence：用来绘制时序图； 1.2 基本元素使用框12graph LRid1 graph LR id1 12graph LRid[I am wxt, I am very happy.] graph LR id[I am wxt, I am very happy.文本框] 12graph LRid(I am wxt, I am very happy.圆角) graph LR id(I am wxt, I am very happy.圆角) 12graph LRid((This is the text in the circle.圆节点)); graph LR id((This is the text in the circle)); 12graph LRid&gt;This is the text in the box非对称节点] graph LR id>This is the text in the box非对称节点] 12graph LRid&#123;This is the text in the box&#125; graph LR id{This is the text in the box菱形节点} 连接线接线中加入标签： 123graph LR; A--&gt;B;%% 箭头链接 graph LR; A-->B; 123graph LRA --- B%% 无箭头 graph LR A --- B %% 无箭头 123graph LRA -- This is the label text --- B;%% 标签 graph LR A -- This is the label text --- B; %% 标签 123graph LRA-- text --&gt;B%% 箭头标签 graph LR A--text-->B 123graph LRA-.-&gt;B%% 虚线 graph LR A-.->B %% 虚线 123graph LRA-.text.-&gt;B%% 标签虚线 graph LR A-.text.->B %% 标签虚线 123graph LRA==&gt;B%% 有向粗实线 graph LR A==>B %% 有向粗实线 123graph LRA===B%% 无向粗实线 graph LR A===B %% 无向粗实线 123graph LRA==text==&gt;B%% 标签粗线 有向 graph LR A==text==>B %% 标签粗线 有向 123graph LRA==text===B%% 标签粗线 无向 graph LR A==text===B %% 标签粗线 无向 特殊语法1、引号可以抑制一些特殊字符的使用，避免一些不必要的麻烦。 12graph LRd1[&quot;This is the (text) in the box&quot;] 2、html字符的转义字符 12graph LR A[&quot;A double quote:#quot;&quot;]--&gt;B[&quot;A dec char:#9829;&quot;] graph LR A["A double quote:#quot;"]-->B["A dec char:#9829;"] 子图基本语法如下： 123subgraph title graph definition end 具体示例如下： 1234567891011graph TB subgraph one a1 --&gt; a2 end subgraph two b2 --&gt; b2 end subgraph three c1 --&gt; c2 end c1 --&gt; a2 graph TB subgraph one a1 --> a2 end subgraph two b2 --> b2 end subgraph three c1 --> c2 end c1 --> a2 基础fontawesome支持在图片之中要加入来自frontawesome的图表字体，需要像frontawesome网站上那样引用的那样。详情：fontawdsome 具体示例如下： 12345graph TD B[&quot;fa:fa-twitter for peace&quot;] B--&gt;C[fa:fa-ban forbidden] B--&gt;D(fa:fa-spinner); B--&gt;E(A fa:fa-camerra-retro perhaps?); graph TD B["fa:fa-twitter for peace"] B-->C[fa:fa-ban forbidden] B-->D(fa:fa-spinner); B-->E(A fa:fa-camerra-retro perhaps?); 1.3 渲染定义连接线的样式 1234graph LR id1(Start)--&gt;id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px; style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray:5,5; graph LR id1(Start)-->id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px; style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray:5,5; 样式为了方便样式的使用，可以定义类来使用样式，类的定义示例如下： 1classDef className fill:#f9f,stroke:#333,stroke-width:4px; 对节点使用样式类： 1class nodeId className; 同时对多个节点使用相同的样式类： 1class nodeId1,nodeId2 className; 可以在CSS中提前定义样式类，应用在图表的定义中。 1234graph LR A--&gt;B[AAABBB]; B--&gt;D; class A cssClass; 默认样式类：当没有指定样式的时候，默认采用。 1classDef default fill:#f9f,stroke:#333,stroke-width:4px; 示例： 123graph LR classDef default fill:#f90,stroke:#555,stroke-width:4px; id1(Start)--&gt;id2(Stop) graph LR classDef default fill:#f90,stroke:#555,stroke-width:4px; id1(Start)-->id2(Stop) 2 时序图(sequence diagram)2.1 基本语法时序图，又叫序列图，为uml中比较常用的图形，在md中如下制作： 12345sequenceDiagram Alice-&gt;&gt;John: Hello John, how are you ? John--&gt;&gt;Alice: Great! Alice-&gt;&gt;John: Huang,you are better . John--&gt;&gt;Alice: yeah, Just not bad. sequenceDiagram Alice->>John: Hello John, how are you ? John-->>Alice: Great! Alice->>John: Huang,you are better . John-->>Alice: yeah, Just not bad. 观察上图，如果想让John出现在前面，让Alice在后面，原图的结构不发生改变，那要如何操作。mermaid通过设定参与者(participants)的顺序控制二者的顺序，示例如下 12345sequenceDiagram participant John participant Alice Alice-xJohn:Hello John,how are you? John--&gt;&gt;Alice:Great! sequenceDiagram participant John participant Alice Alice-xJohn:Hello John,how are you? John-->>Alice:Great! 2.2 消息语法实线或者虚线的使用，Arrow的六种样式 123456-&gt;--&gt;-&gt;&gt;--&gt;&gt;-x--x 具体示例如下： 1234567sequenceDiagram Alice-&gt;John: Hello John, how are you ? John--&gt;Alice:Great! Alice-&gt;&gt;John: dont borther me ! John--&gt;&gt;Alice:Great! Alice-xJohn: wait! John--xAlice: Ok! sequenceDiagram Alice->John: Hello John, how are you ? John-->Alice:Great! Alice->>John: dont borther me ! John-->>Alice:Great! Alice-xJohn: wait! John--xAlice: Ok! 2.3 便签序列图增加便签，具体规则[right of | left of | over][Actor]:Text ，具体示例。 123sequenceDiagram participant John Note left of John: Text in note sequenceDiagram participant John Note left of John: Text in note 跨越两个Actor的便签： 123sequenceDiagram Alice-&gt;&gt;John:Hello John, how are you? Note over Alice,John:A typical interaction sequenceDiagram Alice->>John:Hello John, how are you? Note over Alice,John:A typical interaction 2.4 循环Loops在序列图中，也可以使用循环，具体规则如下： 123loop Loop text... statements...end 示例： 12345sequenceDiagram Alice-&gt;&gt;John: Hello! loop Reply every minute John-&gt;&gt;Alice:Great! end sequenceDiagram Alice->>John: Hello! loop Reply every minute John->>Alice:Great! end 2.5 选择ALT在序列图中选择的表达。规则如下： 12345alt Describing text...statements...else...statements...end 或者使用opt(推荐在没有else的情况下使用) 123opt Describing text...statements...end 示例： 12345678910sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice:not so good :( else is well Bob-&gt;&gt;Alice:Feeling fresh like a daisy:) end opt Extra response Bob-&gt;&gt;Alice:Thanks for asking end sequenceDiagram Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice:not so good :( else is well Bob->>Alice:Feeling fresh like a daisy:) end opt Extra response Bob->>Alice:Thanks for asking end 3 甘特图(gantt)甘特图是一类条形图，由Karol Adamiechi在1896年提出, 而在1910年Henry Gantt也独立的提出了此种图形表示。通常用在对项目终端元素和总结元素的开始及完成时间进行的描述。 示例： 12345678910111213141516171819ganttdateFormat YYYY-MM-DDsection S1T1: 2014-01-01, 9dsection S2T2: 2014-01-11, 9dsection S3T3: 2014-01-02, 9dganttdateFormat YYYY-MM-DDsection S1T1: 2014-01-01, 9dsection S2T2: 2014-01-11, 9dsection S3T3: 2014-01-02, 9d 先来看一个的例子： 123456789101112131415161718192021222324252627ganttdateFormat YYYY-MM-DDtitle Adding GANTT diagram functionality to mermaidsection A sectionCompleted task :done, des1, 2014-01-06,2014-01-08Active task :active, des2, 2014-01-09, 3dFuture task : des3, after des2, 5dFuture task2 : des4, after des3, 5dsection Critical tasksCompleted task in the critical line :crit, done, 2014-01-06,24hImplement parser and jison :crit, done, after des1, 2dCreate tests for parser :crit, active, 3dFuture task in critical line :crit, 5dCreate tests for renderer :2dAdd to mermaid :1dsection DocumentationDescribe gantt syntax :active, a1, after des1, 3dAdd gantt diagram to demo page :after a1 , 20hAdd another diagram to demo page :doc1, after a1 , 48hsection Last sectionDescribe gantt syntax :after doc1, 3dAdd gantt diagram to demo page : 20hAdd another diagram to demo page : 48h gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h 具体关键字中英对应表。 名称 解释 title 标题 dateFormat 日期格式 section 模块 Completed 已经完成 Active 当前正在进行 Future 后续待处理 crit 关键阶段 日期缺失 默认从上一项完成后 关于日期的格式可以参考： string-format Time-Formatting 4 Demo12345678910111213141516graph TB sq[Square shape] --&gt; ci((Circle shape)) subgraph A subgraph di&#123;Diamond with line break&#125; -.-&gt; ro(Rounded) di==&gt;ro2(Rounded square shape) end e --&gt; od3&gt;Really long text with linebreak&lt;br&gt;in an Odd shape] cyr[Cyrillic]--&gt;cyr2((Circle shape Начало)); classDef green fill:#9f6,stroke:#333,stroke-width:2px; classDef orange fill:#f96,stroke:#333,stroke-width:4px; class sq,e green class di orange graph TB sq[Square shape] --> ci((Circle shape)) subgraph A subgraph di{Diamond with line break} -.-> ro(Rounded) di==>ro2(Rounded square shape) end e --> od3>Really long text with linebreakin an Odd shape] cyr[Cyrillic]-->cyr2((Circle shape Начало)); classDef green fill:#9f6,stroke:#333,stroke-width:2px; classDef orange fill:#f96,stroke:#333,stroke-width:4px; class sq,e green class di orange 总结markdown中所有图形的绘制最终其实都是在使用mermaid，该插件的具体官方地址为mermaidis，本文中没有涵盖的需求具体可以在该链接中找到，总结来说这个绘图功能还是很强大的，在写这篇博客的过程中有一个很深的感触，就是你自己认为的一个很特别或者是小众的需求，其实很多的前辈们早就在之前已经想到、做过或者已经给出了完美的解决方案，所有平时没事的时候还是要多接触、多了解、多积累，等到真正使用的时候才不至于抓狂。 本文作者：tongtong本文链接：https://stongtong.github.io/版权申明：网站内容为tongtong所有，转载请注明出处。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown，mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HBASE中LSM Tree]]></title>
    <url>%2F2017%2F04%2F05%2Fhbase01-LSM%20Tree%2F</url>
    <content type="text"><![CDATA[摘要： HBASE最为出色的功能就是大数据量的写入性能，今天要介绍的就是HBASE中核心的数据结构LSM Tree，该数据结构保证了HBASE的数据写入的性能，废话不多说，开始正文。 1 LSM Tree由来​ LSM Tree，全称Log-structured merge-tree，讲LSM树之前，需要提下三种基本的存储引擎，这样才能清楚LSM树的由来。 （1）哈希存储引擎​ 哈希存储引擎，就是以哈希表为基础持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。对于key-value的插入、查询、删除操作，哈希表的复杂度都是O(1)；但如果在需求中需要进行顺序扫描或者范围查找，hash并不能够支持。 （2）B树存储引擎​ B树存储引擎是以B树（一般都是B+树）的持久化实现，该种数据结构不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（下面有详细的解释），这里对B树、B+树进行简单的复习。 ​ 走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见，下面引用其文章中的话。 ​ “B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。“ 为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据库索引？ （1) B+ tree的磁盘读写代价更低 B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 ​ 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 （2）B+tree的查询效率更加稳定​ 由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 （3）B+ 树在顺序查询方面更加优秀 ​ B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。 任何一种数据结构都是针对特定场景的，B+树也不例外，其缺点为： ​ B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO. ​ 从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态） （3）LSM树​ LSM树存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且其通过批量存储技术，规避磁盘随机写入问题，但同时带来的问题就是LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。 ​ 下面将对LSM tree进行详细介绍。 2 LSM Tree原理2.1 设计思想​ LSM树的设计思想非常朴素，简而言之就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，其具体做法是把一棵大树拆分成N棵小树，它首先将内容写入内存中，随着小树越来越大，当达到内存写入阈值后，内存中的小树会flush到磁盘中，这样磁盘中的树定期做merge操作，合并成一棵稳定的大树（优化数据的读性能）。当进行数据读取时，需要合并磁盘中历史数据和内存中最近修改操作，综合两者才能进行完整的数据查找操作。 ​ 批量操作减少了磁盘磁臂的移动次数降低了进行数据插入时磁盘磁臂的开销，所以写入性能大大提升，同时读性能有所下降，LSM在进行需要即时响应的操作时会损失I/O效率，最适用于索引插入比查询操作多的情况。 2.2 详细说明​ LSM-Tree主题思想为划分成不同等级的树。可以想象一份索引由两棵树组成：一个存在于内存（可以使其他树结构），一个存在于磁盘（如下图）。 ​ 数据首先会插入到内存中的树，为了防止数据丢失，写内存的同时需要暂时持久化到磁盘即输入数据时数据会以完全有序的形式先存储在日志文件中（对应HBase的MemStore和HLog）。当日志文件被修改时，对应的更新会被先保存在内存中来加速查询。 ​ 当内存中树的数据达到阈值时，会进行合并操作。合并操作会从左至右遍历内存中的叶子节点与磁盘中树的叶子节点进行合并，当合并的数据量达到磁盘的存储页的大小时，会将合并的数据持久化到磁盘。同时更新父亲节点对叶子节点的指针（如下图）。 ​ 之前存在于磁盘的叶子节点被合并后，这些数据并不会被删除，这些数据会复制一份并与内存中的数据一起顺序写到磁盘。查找通过合并的方式完成，首先搜索内存存储结构，接下来是磁盘存储结构。 ​ LSM树所有节点都是满的并按页存储，经过多次的flush会创建很多数据存储文件，后台线程会将小文件聚合成大文件，因此磁盘的寻道操作就会被限制在一定数目的数据存储文件中，以优化读性能。磁盘上的树结构也可以分割成多个存储文件，因为所有的存储数据都是按照Key有序排列的，因此在现有节点中插入新的关键字不需要重新排序。 ​ LSM-Tree属于传输型，在磁盘传输速率上进行文件的排序和合并以及日志操作，可以更好的拓展到更大的数据规模上，因为它会使用日志文件和一个内存存储结构把随机写操作转化为顺序写，读写独立，不会产生两种操作的竞争。 3 hbase中的LSM-tree3.1 原理HBASE中，数据会先写到内存中，为了防止内存数据丢失，写内存的同时需要持久化到磁盘，对应了HBase的MemStore和HLog（即HBASE中wal，write ahead log）。 ​ MemStore中的数据达到一定的阈值之后，需要将数据刷写到磁盘，即生成HFile（也是一颗小的B+树）文件。 ​ hbase中的minor merge（少量HFile小文件合并）、 major merge（一个region的所有HFile文件合并，可能包括数据删除操作）执行compact操作，同时删除无效数据（过期及删除的数据），多棵小树在这个时机合并成大树，来增强（稳定）读性能。 ​ hbase在实现中，是把整个内存数据达到一定阈值后，flush到disk中，形成一个file，这个file的存储也就是一个小的B+树，因为hbase一般是部署在hdfs上，hdfs不支持对文件的update操作，所以hbase是这样全部内存flush，而不是和磁盘中的小树merge update，这个设计也就能讲通了。内存flush到磁盘上的小树，定期也会合并成一个大树。整体上hbase就是用了lsm tree的思路。 3.2 优化针对LSM树读性能hbase的优化： ​ Bloom-filter:就是个带随机概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定的数据。于是就可以不用二分查找，而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到提升，但付出空间代价。 ​ compact：小树合并为大树，因为小树性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的老数据查询也可以直接使用log2N的方式找到，不需要再进行(N/m)*log2n的查询了。 总结​ HBASE中主要使用LSM-Tree来保证大量写入操作的性能，现在对HBASE的定位也主要集中在数据仓库的角色，存放海量数据，因此其写入需求远大于读取需求；任何一种数据库或者是一种组件，只是针对某些特定场景而存在，不可能针对所有的场景都是适合的，所以在进行技术选型或者产品定位时，在这一方面多考虑一点是特别重要的。 本文作者：tongtong本文链接：https://stongtong.github.io/版权申明：网站内容为tongtong所有，转载请注明出处。]]></content>
      <categories>
        <category>Hbase</category>
      </categories>
      <tags>
        <tag>LSM Tree</tag>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令记录]]></title>
    <url>%2F2016%2F08%2F30%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[简写1234567hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; //新建文章hexo new page &quot;我的类别&quot; //新建目录下的pagehexo p == hexo publish //发布草稿到站点,其用法为hexo publish [layout] &lt;title&gt;hexo g == hexo generate //生成hexo s == hexo server //启动服务，当端口冲突时，其可以使用参数p更改端口，具体用法为hexo s -p 端口号hexo d == hexo deploy //部署hexo c == hexo clean //清楚生成文件 hexo中使用模板在hexo根目录下的scaffolds文件下，有生成创建文章的模板，在生成时，可以进行模板指定：1hexo new photo &quot;My Gallery&quot; //photo为指定模板，创建时其会到scaffolds文件下查找photo.md文件，进行相册的创建。 前置声明12345678layout: 布局，默认为posttitle: 文章名称date: 创建时间updated: 修改时间comments: 评论开关tags: 标签categories: 类别permalink: 永久链接 最后基本就是这么多了，以后用到在继续添加。 本文作者：tongtong本文链接：https://stongtong.github.io/版权申明：网站内容为tongtong所有，转载请注明出处。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github搭建各站记录]]></title>
    <url>%2F2015%2F08%2F29%2FGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本次搭建主要使用hexo，安装主题为next主题，包括站内搜索、站点、RSS、还有统计和评论系统，并实现 blog自动发布完成。 主要步骤1、下载node js和git，安装完成后，在node js中利用npm进行hexo的安装： 1npm install -g hexo-cli 2、在指定目录下初始化hexo目录， 123hexo ini hexocd hexonpm install 这里的目录名称为hexo,将以上软件安装好之后，将原hexo文件夹下的文件目录统一存放在新建的hexo文件下即可，基本的框架搭建完成。 主题配置1、设置语言配置，主要在主题的目录下，查看language目录的支持的语言，之前next主题的中文语言文件为zh-Hans，但现在改成了zh-CN，这个一定要注意，要不然配置不会生效。 2、社交配置和支持的页面目录配置，这一部分主要是根据自己的需要 ，在主题配置文件中进行相应的指定，比较简单，需要说明的是，在指定图标的时候是在链接的后面用英文指定，next图标库支持600+图标这个能很好的满足；放开相关页面目录的配置，一定要新建目录页，比如categories，需要用hexo new page来创建这个页面，要不然会报错。 部署功能要将写好的文件进行部署，需要安装插件，安装步骤为 1npm install hexo-deployer-git --save 安装完毕使用hexo d命令进行部署。 RSS功能和mapsite功能进行Rss功能扩展需要安装插件， 1npm install hexo-generator-feed --save 安装完毕后，会在hexo目录中出现node_modules文件夹，然后需要在hexo配置文件和主题配置文件中进行配置如下：1、hexo配置文件 12345feed: type: atom path: atom.xml limit: 20 hub: 2、主题配置文件 1rss: /atom.xml 然后重启博客，在生成文件时，就会产生atom.xml文件，显示安装成功。安装百度map-site功能1npm install hexo-generator-baidu-mapsite --save 1、在hexo配置文件 12baidusitemap: path: baidusitemap.xml 2、在主题配置文件1sitemap: /baidusitemap.xml 重启博客后，点击查看。(npm install hexo-baidu-url-push –save) 自定义站点搜索安装插件1npm install hexo-generator-searchdb --save 1、在hexo配置文件12345search: path: search.xml field: post format: html limit: 10000 2、在主题文件中配置12local_search: enable: true 配置分类和标签next主题中的分类和标签要通过新建index文件来产生。具体操作如下运行 hexo new page tags 命令后会产生 source/tags/index.md 这个文件，你要修改这个文件，在里面添加一句话type: “tags”。123title: &quot;tags&quot;date: 2015-03-24 08:58:02 添加：1type: &quot;tags&quot; 然后运行服务器即可访问tags页面了。 在 2015-05-29 06:22:57，”Leon Lin” notifications@github.com 写道：123456789101112$ cd path/to/hexo$ hexo new page tags$ hexo new page categories$ vim source/tags/index.mdadd line: type: &quot;tags&quot;$ vim source/categories/index.mdadd line: type: &quot;categories&quot;$ hexo d -g 做完之後產生的 /tags/index.html 裡面沒有顯示出所用的tag… valine评论next主题支持多说、友言、畅言、来必力等评论系统，这里说一下，多说已经与17年6月关闭了自己的评论系统，原因估计是不赚钱，友言的评论系统很是难用这里也不多说了，畅言系统要求必须要有国内的ICP备案号，这一点比较坑，自己搭个各站，还要去备案，太过复杂，这里就只剩下来必力了，不过这几种，我都有尝试，尝试下来感觉都不太好，前段时间看到了一个基于LeanCloud的全新的评论系统valine，总结一个词就是好用，所以这里极力推荐使用valine作为评论系统，具体配置也很简单，基本你看了主题的这部分配置项就会明白，和阅读统计基本上差不多。 添加阅读统计在LeanCloud注册账号，创建应用并制定Counter，然后获取AppId和App key在主题配置文件中指定，需要注意的是，这里需要对创建的计数进行安全限制，相关操作hexo论坛有很多，这里不再说明。 在leancloud上注册账号，本账号具体为 然后新建一个应用，应用的名称可以随便选取，在该应用中新建一个class，class权限设置为最大，class名称为Counter，然后进入设置，可以获取ID和Key， 获取之后，在主题配置文件中进行设定：1234leancloud_visitors: enable: true app_id: C5p app_key: iD 重启blog即可。 本文作者：tongtong本文链接：https://stongtong.github.io/版权申明：网站内容为tongtong所有，转载请注明出处。]]></content>
      <categories>
        <category>next</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>person</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题内置标签]]></title>
    <url>%2F2015%2F03%2F23%2FNext%E4%B8%BB%E9%A2%98%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[该文章测试next主题中的图片表示，因为看到官网上有很多的内置标签，测试一下，方便以后使用。 字体居中HTML方式1&lt;blockquote class=&quot;blockquote-center&quot;&gt;该部分为文字居中&lt;/blockquote&gt; 该部分为文字居中 内置标签方式1&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125; 居中文字标签模式 标签简写模式12&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 突破宽度限制图片当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。 此标签有两种调用方式（详细参看底下示例）： HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。1&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt; 标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。1&#123;% fullimage /image-url, alt, title %&#125; 可以简写为：12&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125; 这里是markdown自带的显示： 以上三种比较，很是明显。 bootstrap callout使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值：123456defaultprimarysuccessinfowarningdanger 演示效果 此类别为default 此类别为primary 此类别为success 此类别为info 此类别为warning 此类别为danger 本文作者：tongtong本文链接：https://stongtong.github.io/版权申明：网站内容为tongtong所有，转载请注明出处。]]></content>
      <categories>
        <category>next</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
</search>
