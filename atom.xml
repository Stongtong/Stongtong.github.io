<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XTong notes</title>
  
  <subtitle>Live beautifully, dream passionately, love completely</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tongfan.xyz/"/>
  <updated>2019-02-18T12:18:01.725Z</updated>
  <id>https://tongfan.xyz/</id>
  
  <author>
    <name>XiaoTong Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HBASE中的数据刷写</title>
    <link href="https://tongfan.xyz/2019/02/17/HBASE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%B7%E5%86%99/"/>
    <id>https://tongfan.xyz/2019/02/17/HBASE中的数据刷写/</id>
    <published>2019-02-17T11:27:58.000Z</published>
    <updated>2019-02-18T12:18:01.725Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：由于HBASE中使用LSM，所以在HBASE中插入数据时，是批量从内存中flush到磁盘（HDFS），本文介绍总结HBASE中触发flush动作的详细条件，从而对flush过程进行优化。（本文参考自<a href="https://mp.weixin.qq.com/s/lEfTrbd7bB4Xi0s86drr3g">HBASE社区文章</a>）</p><a id="more"></a><h1 id="写数据过程简介"><a href="#写数据过程简介" class="headerlink" title="写数据过程简介"></a>写数据过程简介</h1><p>HBASE数据写入都是先将数据写入内存，在内存中存在memstore的结构（在写入内存之前会先通过wal进行日志的备份，相信大家都知道这个），memstore中的数据最终会持久化到磁盘，持久化的原理就是之前文章说的LSM数据结构（内存树与磁盘树的合并），最终在磁盘上以hfile的方式进行存储，这里附HBASE的一张整体结构图，该图较为清晰的对memstore、hfile以及其他HBASE的概念的关系进行说明。</p><p><img src="https://i.loli.net/2019/02/17/5c694ac4a683b.png" alt></p><p>理解 MemStore 的刷写对优化 MemStore 有很重要的意义，大部分人遇到的性能问题都是写操作被阻塞(Block)无法写入HBase。本文基于 HBase 2.0.2，并对 MemStore 的 Flush 进行说明，包括哪几种条件触发 Memstore Flush 和目前常见的刷写策略(FlushPolicy)。</p><h1 id="触发Flush条件"><a href="#触发Flush条件" class="headerlink" title="触发Flush条件"></a>触发Flush条件</h1><p>有很多情况会触发 MemStore 的 Flush 操作，所以我们最好需要了解每种情况在什么时候触发 Memstore Flush。总的来说，主要有以下几种情况会触发 Memstore Flush：</p><ul><li>Region中所有MemStore占用的内存超过阈值范围</li><li>整个RegionServer的MemStore占用内存总和大于相关阈值</li><li>WAL数量大于相关阈值</li><li>定期自动刷写</li><li>数据更新超过一定阈值</li><li>手动触发刷写</li></ul><p>下面对如上集中情况进行详细说明。</p><h2 id="Region中所有memstore占用内存超过阈值"><a href="#Region中所有memstore占用内存超过阈值" class="headerlink" title="Region中所有memstore占用内存超过阈值"></a>Region中所有memstore占用内存超过阈值</h2><p>当一个 Region 中所有 MemStore 占用的内存(包括 OnHeap + OffHeap)大小超过<strong>刷写阈值</strong>的时候会触发一次刷写，这个阈值由 <code>hbase.hregion.memstore.flush.size</code> 参数控制，默认为128MB。我们每次调用 put、delete 等操作都会检查的这个条件的。</p><p>但是如果我们的数据增加得很快，达到 <code>hbase.hregion.memstore.flush.size * hbase.hregion.memstore.block.multiplier</code> 的大小，<code>hbase.hregion.memstore.block.multiplier</code> 默认值为4，也就是128*4=512MB的时候，那么除了触发 MemStore 刷写之外，HBase 还会在刷写的时候同时阻塞所有写入该 Store 的写请求（这是因为写入速率太快，如果不限制写入数据的请求，很可能导致HBASE内存空间被占满的情况）！这时候如果你往对应的 Store 写数据，会出现 <code>RegionTooBusyException</code> 异常。</p><h2 id="RegionServer-的-MemStore-占用内存总和大于相关阈值"><a href="#RegionServer-的-MemStore-占用内存总和大于相关阈值" class="headerlink" title="RegionServer 的 MemStore 占用内存总和大于相关阈值"></a>RegionServer 的 MemStore 占用内存总和大于相关阈值</h2><p>HBase 为 RegionServer 的 MemStore 分配一定的写缓存，大小等于 <code>hbase_heapsize(RegionServer占用的堆内存大小)* hbase.regionserver.global.memstore.size</code>。<code>hbase.regionserver.global.memstore.size</code> 的默认值是 0.4，也就是说写缓存大概占用 RegionServer 整个 JVM 内存使用量的 40%。</p><p>如果整个 RegionServer 的 MemStore 占用内存总和大于 <code>hbase.regionserver.global.memstore.size.lower.limit * hbase.regionserver.global.memstore.size * hbase_heapsize</code> 的时候，将会触发 MemStore 的刷写。其中 <code>hbase.regionserver.global.memstore.size.lower.limit</code> 的默认值为 0.95。</p><p>举个例子，如果我们 HBase 堆内存总共是 32G，按照默认的比例，那么触发 RegionServer 级别的 Flush 是 RegionServer 中所有的 MemStore 占用内存为：32 <em> 0.4 </em> 0.95 = 12.16G。</p><p><strong>注意</strong>：0.99.0 之前 <code>hbase.regionserver.global.memstore.size</code> 是 <code>hbase.regionserver.global.memstore.upperLimit</code> 参数；<code>hbase.regionserver.global.memstore.size.lower.limit</code> 是 <code>hbase.regionserver.global.memstore.lowerLimit</code>，参见 HBASE-5349</p><p>RegionServer 级别的 Flush 策略是每次找到 RS 中占用内存最大的 Region 对它进行刷写，这个操作是循环进行的，直到总体内存的占用低于全局 MemStore 刷写下<br>限(<code>hbase.regionserver.global.memstore.size.lower.limit * hbase.regionserver.global.memstore.size * hbase_heapsize</code>)才会停止。</p><p>需要<strong>注意</strong>的是，如果达到了 RegionServer 级别的 Flush，那么当前 RegionServer 的所有写操作将会被阻塞，而且这个阻塞可能会持续到分钟级别。（敏感的人已经发现在这应该尽量避免RegionServer级别的flush）</p><h2 id="WAL数量大于相关阈值"><a href="#WAL数量大于相关阈值" class="headerlink" title="WAL数量大于相关阈值"></a>WAL数量大于相关阈值</h2><p>WAL(write-ahead log，预写日志)用来解决宕机之后的操作恢复问题的。数据到达 Region 的时候是先写入 WAL，然后再被写到 Memstore 的。如果 WAL 的数量越来越大，这就意味着 MemStore 中未持久化到磁盘的数据越来越多。当 RS 挂掉的时候，恢复时间将会变长，所以有必要在 WAL 到达一定的数量时进行一次刷写操作。阈值 maxLogs 的计算公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schedule a WAL roll when the WAL is 50% of the HDFS block size. Scheduling at 50% of block</span></span><br><span class="line"><span class="comment">// size should make it so WAL rolls before we get to the end-of-block (Block transitions cost</span></span><br><span class="line"><span class="comment">// some latency). In hbase-1 we did this differently. We scheduled a roll when we hit 95% of</span></span><br><span class="line"><span class="comment">// the block size but experience from the field has it that this was not enough time for the</span></span><br><span class="line"><span class="comment">// roll to happen before end-of-block. So the new accounting makes WALs of about the same</span></span><br><span class="line"><span class="comment">// size as those made in hbase-1 (to prevent surprise), we now have default block size as</span></span><br><span class="line"><span class="comment">// 2 times the DFS default: i.e. 2 * DFS default block size rolling at 50% full will generally</span></span><br><span class="line"><span class="comment">// make similar size logs to 1 * DFS default block size rolling at 95% full. See HBASE-19148.</span></span><br><span class="line"><span class="keyword">this</span>.blocksize = WALUtil.getWALBlockSize(<span class="keyword">this</span>.conf, <span class="keyword">this</span>.fs, <span class="keyword">this</span>.walDir);</span><br><span class="line"><span class="keyword">float</span> multiplier = conf.getFloat(<span class="string">"hbase.regionserver.logroll.multiplier"</span>, <span class="number">0.5f</span>);</span><br><span class="line"><span class="keyword">this</span>.logrollsize = (<span class="keyword">long</span>)(<span class="keyword">this</span>.blocksize * multiplier);</span><br><span class="line"><span class="keyword">this</span>.maxLogs = conf.getInt(<span class="string">"hbase.regionserver.maxlogs"</span>,</span><br><span class="line">      Math.max(<span class="number">32</span>, calculateMaxLogFiles(conf, logrollsize)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Public because of FSHLog. Should be package-private</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> isRecoverEdits the created writer is for recovered edits or WAL.</span></span><br><span class="line"><span class="comment">  *                       For recovered edits, it is true and for WAL it is false.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getWALBlockSize</span><span class="params">(Configuration conf, FileSystem fs, Path dir,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isRecoverEdits)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> defaultBlockSize = CommonFSUtils.getDefaultBlockSize(fs, dir) * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRecoverEdits) &#123;</span><br><span class="line">     <span class="keyword">return</span> conf.getLong(<span class="string">"hbase.regionserver.recoverededits.blocksize"</span>, defaultBlockSize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> conf.getLong(<span class="string">"hbase.regionserver.hlog.blocksize"</span>, defaultBlockSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateMaxLogFiles</span><span class="params">(Configuration conf, <span class="keyword">long</span> logRollSize)</span> </span>&#123;</span><br><span class="line">  Pair&lt;Long, MemoryType&gt; globalMemstoreSize = MemorySizeUtil.getGlobalMemStoreSize(conf);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>) ((globalMemstoreSize.getFirst() * <span class="number">2</span>) / logRollSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果设置 <code>hbase.regionserver.maxlogs</code>，那就是这个参数的值；否则是 <code>max(32, hbase_heapsize * hbase.regionserver.global.memstore.size * 2 / logRollSize)</code>。如果某个 RegionServer 的 WAL 数量大于 maxLogs 就会触发 MemStore 的刷写。</p><p>WAL 数量触发的刷写策略是，找到最旧的 un-archived WAL 文件，并找到这个 WAL 文件对应的 Regions， 然后对这些 Regions 进行刷写。</p><h2 id="定期自动刷写"><a href="#定期自动刷写" class="headerlink" title="定期自动刷写"></a>定期自动刷写</h2><p>如果我们很久没有对 HBase 的数据进行更新，这时候就可以依赖定期刷写策略了。RegionServer 在启动的时候会启动一个线程 PeriodicMemStoreFlusher 每隔 <code>hbase.server.thread.wakefrequency</code> 时间检查属于这个 RegionServer 的 Region 有没有超过一定时间都没有刷写，这个时间是由 <code>hbase.regionserver.optionalcacheflushinterval</code> 参数控制的，默认是 3600000，单位ms，也就是1小时会进行一次刷写。如果设定为0，则意味着关闭定时自动刷写。</p><p>为了防止一次性有过多的 MemStore 刷写，定期自动刷写会有 0 ~ 5 分钟的延迟，具体参见 PeriodicMemStoreFlusher 类的实现。</p><h2 id="数据更新超过一定阈值"><a href="#数据更新超过一定阈值" class="headerlink" title="数据更新超过一定阈值"></a>数据更新超过一定阈值</h2><p>如果 HBase 的某个 Region 更新的很频繁，而且既没有达到自动刷写阀值，也没有达到内存的使用限制，但是内存中的更新数量已经足够多，比如超过 <code>hbase.regionserver.flush.per.changes</code> 参数配置，默认为30000000，那么也是会触发刷写的。</p><h2 id="手动触发刷写"><a href="#手动触发刷写" class="headerlink" title="手动触发刷写"></a>手动触发刷写</h2><p>除了 HBase 内部一些条件触发的刷写之外，我们还可以通过执行相关命令或 API 来触发 MemStore 的刷写操作。比如调用可以调用 Admin 接口提供的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Flush a table. Synchronous operation.</span><br><span class="line">  *</span><br><span class="line">  * @param tableName table to flush</span><br><span class="line">  * @throws IOException if a remote or network exception occurs</span><br><span class="line">  */</span><br><span class="line">void flush(TableName tableName) throws IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * Flush an individual region. Synchronous operation.</span><br><span class="line">  *</span><br><span class="line">  * @param regionName region to flush</span><br><span class="line">  * @throws IOException if a remote or network exception occurs</span><br><span class="line">  */</span><br><span class="line">void flushRegion(byte[] regionName) throws IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * Flush all regions on the region server. Synchronous operation.</span><br><span class="line">  * @param serverName the region server name to flush</span><br><span class="line">  * @throws IOException if a remote or network exception occurs</span><br><span class="line">  */</span><br><span class="line">void flushRegionServer(ServerName serverName) throws IOException;</span><br></pre></td></tr></table></figure><p>分别对某张表、某个 Region 或者某个 RegionServer 进行刷写操作。也可以在 Shell 中通过执行 flush 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; flush &apos;TABLENAME&apos;</span><br><span class="line">hbase&gt; flush &apos;REGIONNAME&apos;</span><br><span class="line">hbase&gt; flush &apos;ENCODED_REGIONNAME&apos;</span><br><span class="line">hbase&gt; flush &apos;REGION_SERVER_NAME&apos;</span><br></pre></td></tr></table></figure><p>需要注意的是，以上所有条件触发的刷写操作最后都会检查对应的 HStore 包含的 StoreFiles 文件超过 <code>hbase.hstore.blockingStoreFiles</code> 参数配置的个数，默认值是16。如果满足这个条件，那么当前刷写会被推迟到 <code>hbase.hstore.blockingWaitTime</code> 参数设置的时间后再刷写。在阻塞刷写的同时，HBase 还会请求 Split 或 Compaction 操作。（在flush之前，先对region进行分离或者合并操作）</p><h1 id="哪些操作触发-MemStore-Flush"><a href="#哪些操作触发-MemStore-Flush" class="headerlink" title="哪些操作触发 MemStore Flush"></a>哪些操作触发 <strong>MemStore Flush</strong></h1><p>我们常见的 put、delete、append、increment、调用 flush 命令、Region 分裂、Region Merge、bulkLoad HFiles 以及给表做快照操作都会对上面的相关条件做检查，以便判断要不要做刷写操作。</p><h1 id="MemStore-Flush策略-FlushPolicy"><a href="#MemStore-Flush策略-FlushPolicy" class="headerlink" title="MemStore Flush策略(FlushPolicy)"></a>MemStore Flush策略(FlushPolicy)</h1><p>在 HBase 1.1 之前，MemStore 刷写是 Region 级别的。就是说，如果要刷写某个 MemStore ，MemStore 所在的 Region 中其他 MemStore 也是会被一起刷写的！这会造成一定的问题，比如小文件问题，具体参见 <a href="https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650716323&amp;idx=1&amp;sn=ccace248f650d4a3bcc2ff60103fc4a1&amp;scene=21#wechat_redirect">《为什么不建议在 HBase 中使用过多的列族》</a>。针对这个问题，HBASE-10201/HBASE-3149引入列族级别的刷写。我们可以通过 <code>hbase.regionserver.flush.policy</code> 参数选择不同的刷写策略。</p><p>目前 HBase 2.0.2 的刷写策略全部都是实现 FlushPolicy 抽象类的。并且自带三种刷写策略：<code>FlushAllLargeStoresPolicy</code>、<code>FlushNonSloppyStoresFirstPolicy</code> 以及 <code>FlushAllStoresPolicy</code>。</p><h2 id="FlushAllStoresPolicy"><a href="#FlushAllStoresPolicy" class="headerlink" title="FlushAllStoresPolicy"></a><strong>FlushAllStoresPolicy</strong></h2><p>这种刷写策略实现最简单，直接返回当前 Region 对应的所有 MemStore。也就是每次刷写都是对 Region 里面所有的 MemStore 进行的，这个行为和 HBase 1.1 之前是一样的。</p><h2 id="FlushAllLargeStoresPolicy"><a href="#FlushAllLargeStoresPolicy" class="headerlink" title="FlushAllLargeStoresPolicy"></a><strong>FlushAllLargeStoresPolicy</strong></h2><p>在 HBase 2.0 之前版本是 FlushLargeStoresPolicy，后面被拆分成分 FlushAllLargeStoresPolicy 和FlushNonSloppyStoresFirstPolicy，参见 HBASE-14920。</p><p>这种策略会先判断 Region 中每个 MemStore 的使用内存(OnHeap+OffHeap)是否大于某个阀值，大于这个阀值的 MemStore 将会被刷写。阀值的计算是由 <code>hbase.hregion.percolumnfamilyflush.size.lower.bound</code> 、<code>hbase.hregion.percolumnfamilyflush.size.lower.bound.min</code> 以及 <code>hbase.hregion.memstore.flush.size</code> 参数决定的。计算逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//region.getMemStoreFlushSize() / familyNumber</span></span><br><span class="line"><span class="comment">//就是 hbase.hregion.memstore.flush.size 参数的值除以相关表列族的个数</span></span><br><span class="line">flushSizeLowerBound = max(region.getMemStoreFlushSize() / familyNumber, hbase.hregion.percolumnfamilyflush.size.lower.bound.min)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果设置了 hbase.hregion.percolumnfamilyflush.size.lower.bound</span></span><br><span class="line">flushSizeLowerBound = hbase.hregion.percolumnfamilyflush.size.lower.bound</span><br></pre></td></tr></table></figure><p><code>hbase.hregion.percolumnfamilyflush.size.lower.bound.min</code> 默认值为 16MB，而 <code>hbase.hregion.percolumnfamilyflush.size.lower.bound</code> 没有设置。</p><p>比如当前表有3个列族，其他用默认的值，那么 flushSizeLowerBound = max((long)128 / 3, 16) = 42。</p><p><strong>如果当前 Region 中没有 MemStore 的使用内存大于上面的阀值，FlushAllLargeStoresPolicy 策略就退化成 FlushAllStoresPolicy 策略了，也就是会对 Region 里面所有的 MemStore 进行 Flush。</strong></p><h2 id="FlushNonSloppyStoresFirstPolicy"><a href="#FlushNonSloppyStoresFirstPolicy" class="headerlink" title="FlushNonSloppyStoresFirstPolicy"></a><strong>FlushNonSloppyStoresFirstPolicy</strong></h2><p>HBase 2.0 引入了 in-memory compaction，参见 HBASE-13408。如果我们对相关列族 <code>hbase.hregion.compacting.memstore.type</code> 参数的值不是 NONE，那么这个 MemStore 的 isSloppyMemStore 值就是 true，否则就是 false。</p><p>FlushNonSloppyStoresFirstPolicy 策略将 Region 中的 MemStore 按照 isSloppyMemStore 分到两个 HashSet 里面（sloppyStores 和 regularStores）。然后</p><ul><li>判断 regularStores 里面是否有 MemStore 内存占用大于相关阀值的 MemStore ，有的话就会对这些 MemStore 进行刷写，其他的不做处理，这个阀值计算和 FlushAllLargeStoresPolicy 的阀值计算逻辑一致。</li><li>如果 regularStores 里面没有 MemStore 内存占用大于相关阀值的 MemStore，这时候就开始在 sloppyStores 里面寻找是否有 MemStore 内存占用大于相关阀值的 MemStore，有的话就会对这些 MemStore 进行刷写，其他的不做处理。</li><li>如果上面 sloppyStores 和 regularStores 都没有满足条件的 MemStore 需要刷写，这时候就 FlushNonSloppyStoresFirstPolicy 策略久退化成 FlushAllStoresPolicy 策略了。</li></ul><h1 id="MemStore-Flush-刷写过程"><a href="#MemStore-Flush-刷写过程" class="headerlink" title="MemStore Flush 刷写过程"></a><strong>MemStore Flush</strong> <strong>刷写过程</strong></h1><p>MemStore 的刷写过程很复杂，很多操作都可能触发，但是这些条件触发的刷写最终都是调用 HRegion 类中的 internalFlushcache 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Flush the memstore. Flushing the memstore is a little tricky. We have a lot of updates in the</span><br><span class="line">  * memstore, all of which have also been written to the wal. We need to write those updates in the</span><br><span class="line">  * memstore out to disk, while being able to process reads/writes as much as possible during the</span><br><span class="line">  * flush operation.</span><br><span class="line">  * &lt;p&gt;</span><br><span class="line">  * This method may block for some time. Every time you call it, we up the regions sequence id even</span><br><span class="line">  * if we don&apos;t flush; i.e. the returned region id will be at least one larger than the last edit</span><br><span class="line">  * applied to this region. The returned id does not refer to an actual edit. The returned id can</span><br><span class="line">  * be used for say installing a bulk loaded file just ahead of the last hfile that was the result</span><br><span class="line">  * of this flush, etc.</span><br><span class="line">  * @param wal Null if we&apos;re NOT to go via wal.</span><br><span class="line">  * @param myseqid The seqid to use if &lt;code&gt;wal&lt;/code&gt; is null writing out flush file.</span><br><span class="line">  * @param storesToFlush The list of stores to flush.</span><br><span class="line">  * @return object describing the flush&apos;s state</span><br><span class="line">  * @throws IOException general io exceptions</span><br><span class="line">  * @throws DroppedSnapshotException Thrown when replay of WAL is required.</span><br><span class="line">  */</span><br><span class="line">protected FlushResultImpl internalFlushcache(WAL wal, long myseqid,</span><br><span class="line">     Collection&lt;HStore&gt; storesToFlush, MonitoredTask status, boolean writeFlushWalMarker,</span><br><span class="line">     FlushLifeCycleTracker tracker) throws IOException &#123;</span><br><span class="line">   PrepareFlushResult result =</span><br><span class="line">       internalPrepareFlushCache(wal, myseqid, storesToFlush, status, writeFlushWalMarker, tracker);</span><br><span class="line">   if (result.result == null) &#123;</span><br><span class="line">     return internalFlushCacheAndCommit(wal, status, result, storesToFlush);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return result.result; // early exit due to failure from prepare stage</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的实现可以看出，Flush 操作主要分以下几步做的</p><ul><li><strong>prepareFlush</strong> 阶段：刷写的第一步是对 MemStore 做 snapshot，为了防止刷写过程中更新的数据同时在 snapshot 和 MemStore 中而造成后续处理的困难，所以在刷写期间需要持有 updateLock 。持有了 updateLock 之后，这将阻塞客户端的写操作。所以只在创建 snapshot 期间持有 updateLock，而且 snapshot 的创建非常快，所以此锁期间对客户的影响一般非常小。对 MemStore 做 snapshot 是 internalPrepareFlushCache 里面进行的。</li><li><strong>flushCache</strong> 阶段：如果创建快照没问题，那么返回的 result.result 将为 null。这时候我们就可以进行下一步 internalFlushCacheAndCommit。其实 internalFlushCacheAndCommit 里面包含两个步骤：flushCache 和 commit 阶段。flushCache 阶段其实就是将 prepareFlush 阶段创建好的快照写到临时文件里面，临时文件是存放在对应 Region 文件夹下面的 .tmp 目录里面。</li><li><strong>commit</strong> 阶段：将 flushCache 阶段生产的临时文件移到(rename)对应的列族目录下面，并做一些清理工作，比如删除第一步生成的 snapshot。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HBASE的使用并不是很复杂，甚至很多人认为有点简单，但是涉及到大数据量时，往往会出现很多“意想不到”的问题，这种情况下深入到数据库的实现细节，根据其原理去定向的优化数据库就很是重要的，说到底还是要在源码级别对一个东西有系统性的认识。</p><div class="note primary">            <h4 id="本文作者：tongtong"><a href="#本文作者：tongtong" class="headerlink" title="本文作者：tongtong"></a>本文作者：tongtong</h4><h4 id="本文链接：https-stongtong-github-io"><a href="#本文链接：https-stongtong-github-io" class="headerlink" title="本文链接：https://stongtong.github.io/"></a>本文链接：<a href="https://stongtong.github.io/">https://stongtong.github.io/</a></h4><h4 id="版权申明：网站内容为tongtong所有，转载请注明出处。"><a href="#版权申明：网站内容为tongtong所有，转载请注明出处。" class="headerlink" title="版权申明：网站内容为tongtong所有，转载请注明出处。"></a>版权申明：网站内容为tongtong所有，转载请注明出处。</h4>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：由于HBASE中使用LSM，所以在HBASE中插入数据时，是批量从内存中flush到磁盘（HDFS），本文介绍总结HBASE中触发flush动作的详细条件，从而对flush过程进行优化。（本文参考自&lt;a href=&quot;https://mp.weixin.qq.com/s/lEfTrbd7bB4Xi0s86drr3g&quot;&gt;HBASE社区文章&lt;/a&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="Hbase" scheme="https://tongfan.xyz/categories/Hbase/"/>
    
    
      <category term="Hbase" scheme="https://tongfan.xyz/tags/Hbase/"/>
    
      <category term="flush" scheme="https://tongfan.xyz/tags/flush/"/>
    
  </entry>
  
  <entry>
    <title>markdown中的绘图语法</title>
    <link href="https://tongfan.xyz/2018/01/13/markdown%E4%B8%AD%E7%9A%84%E7%BB%98%E5%9B%BE%E8%AF%AD%E6%B3%95-md/"/>
    <id>https://tongfan.xyz/2018/01/13/markdown中的绘图语法-md/</id>
    <published>2018-01-13T11:12:24.000Z</published>
    <updated>2019-02-18T12:17:39.768Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong>一直在用七牛云作为博客的图床，但是之前发现在七牛云的图床网址必须要进行备案了，太委屈！我自己的个人网站，就是在写写自己的日记、技术笔记、工作感悟、巴拉巴拉巴拉，还要让我备案，真是没地说理去；辗转反侧，也不能因为这个事情不写、不记录啊，所以最近萌生了博客无图的想法，之前用markdown的时候正好接触过markdown的绘图功能，身材很好（轻量级）并且该有的都有，哈哈，今天用这篇博客记录一下markdown中的常用绘图语法，方便以后使用。</p><a id="more"></a><h1 id="1-语法介绍"><a href="#1-语法介绍" class="headerlink" title="1 语法介绍"></a>1 语法介绍</h1><p>markdown能够绘制的图形有很多种，例如最常见的框图、流程图、甘特图、时序图等等，这里先对其关键字进行介绍。</p><h2 id="1-1-基本关键字"><a href="#1-1-基本关键字" class="headerlink" title="1.1 基本关键字"></a>1.1 基本关键字</h2><ul><li><p>mermaid：主要用来绘制框图、甘特图、时序图等，该关键字是比较标准的用法，配合其他关键字能够完成特定图形的绘制；</p><ul><li><p>gantt：绘制甘特图；</p></li><li><p>sequenceDiagram：绘制时序图（UML）；</p></li><li><p>graph ：绘制框图时，图形的位置，后面可接收方向关键词，具体如下（比较简单，不再解释）：</p><ul><li><p>TB - top bottom </p></li><li><p>BT - bottom top </p></li><li>RL - right left </li><li>LR - left right </li><li>TD - as same TB</li></ul></li></ul></li><li><p>flow：用来绘制完整的流程图；</p></li><li><p>sequence：用来绘制时序图；</p></li></ul><h2 id="1-2-基本元素使用"><a href="#1-2-基本元素使用" class="headerlink" title="1.2 基本元素使用"></a>1.2 基本元素使用</h2><h3 id="框"><a href="#框" class="headerlink" title="框"></a>框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRid1</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id[I am wxt, I am very happy.]</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRid[I am wxt, I am very happy.文本框]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id(I am wxt, I am very happy.圆角)</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRid(I am wxt, I am very happy.圆角)</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id((This is the text in the circle.圆节点));</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRid((This is the text in the circle));</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id&gt;This is the text in the box非对称节点]</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRid>This is the text in the box非对称节点]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id&#123;This is the text in the box&#125;</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRid{This is the text in the box菱形节点}</pre><h3 id="连接线"><a href="#连接线" class="headerlink" title="连接线"></a>连接线</h3><p>接线中加入标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">  A--&gt;B;</span><br><span class="line">%% 箭头链接</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LR;  A-->B;</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A --- B</span><br><span class="line">%% 无箭头</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA --- B%% 无箭头</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A -- This is the label text --- B;</span><br><span class="line">%% 标签</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA -- This is the label text --- B;%% 标签</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A-- text --&gt;B</span><br><span class="line">%% 箭头标签</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA--text-->B</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A-.-&gt;B</span><br><span class="line">%% 虚线</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA-.->B%% 虚线</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A-.text.-&gt;B</span><br><span class="line">%% 标签虚线</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA-.text.->B%% 标签虚线</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A==&gt;B</span><br><span class="line">%% 有向粗实线</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA==>B%% 有向粗实线</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A===B</span><br><span class="line">%% 无向粗实线</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA===B%% 无向粗实线</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A==text==&gt;B</span><br><span class="line">%% 标签粗线 有向</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA==text==>B%% 标签粗线 有向</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A==text===B</span><br><span class="line">%% 标签粗线 无向</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRA==text===B%% 标签粗线 无向</pre><h3 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h3><p>1、引号可以抑制一些特殊字符的使用，避免一些不必要的麻烦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1[&quot;This is the (text) in the box&quot;]</span><br></pre></td></tr></table></figure><p>2、html字符的转义字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">        A[&quot;A double quote:#quot;&quot;]--&gt;B[&quot;A dec char:#9829;&quot;]</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LR        A["A double quote:#quot;"]-->B["A dec char:#9829;"]</pre><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subgraph title </span><br><span class="line">graph definition </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>具体示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">        subgraph one</span><br><span class="line">        a1 --&gt; a2</span><br><span class="line">        end</span><br><span class="line">        subgraph two</span><br><span class="line">        b2 --&gt; b2</span><br><span class="line">        end</span><br><span class="line">        subgraph three</span><br><span class="line">        c1 --&gt; c2</span><br><span class="line">        end</span><br><span class="line">        c1 --&gt; a2</span><br></pre></td></tr></table></figure><pre class="mermaid">graph TB        subgraph one        a1 --> a2        end        subgraph two        b2 --> b2        end        subgraph three        c1 --> c2        end        c1 --> a2</pre><h3 id="基础fontawesome支持"><a href="#基础fontawesome支持" class="headerlink" title="基础fontawesome支持"></a>基础fontawesome支持</h3><p>在图片之中要加入来自frontawesome的图表字体，需要像frontawesome网站上那样引用的那样。详情：<a href="http://fontawesome.io/">fontawdsome</a></p><p>具体示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">      B[&quot;fa:fa-twitter for peace&quot;]</span><br><span class="line">      B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">      B--&gt;D(fa:fa-spinner);</span><br><span class="line">      B--&gt;E(A fa:fa-camerra-retro perhaps?);</span><br></pre></td></tr></table></figure><pre class="mermaid">graph TD      B["fa:fa-twitter for peace"]      B-->C[fa:fa-ban forbidden]      B-->D(fa:fa-spinner);      B-->E(A fa:fa-camerra-retro perhaps?);</pre><h2 id="1-3-渲染"><a href="#1-3-渲染" class="headerlink" title="1.3 渲染"></a>1.3 渲染</h2><p>定义连接线的样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">     id1(Start)--&gt;id2(Stop)</span><br><span class="line">     style id1 fill:#f9f,stroke:#333,stroke-width:4px;</span><br><span class="line">     style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray:5,5;</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LR     id1(Start)-->id2(Stop)     style id1 fill:#f9f,stroke:#333,stroke-width:4px;     style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray:5,5;</pre><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>为了方便样式的使用，可以定义类来使用样式，类的定义示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classDef className fill:#f9f,stroke:#333,stroke-width:4px;</span><br></pre></td></tr></table></figure><p>对节点使用样式类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class nodeId className;</span><br></pre></td></tr></table></figure><p>同时对多个节点使用相同的样式类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class nodeId1,nodeId2 className;</span><br></pre></td></tr></table></figure><p>可以在CSS中提前定义样式类，应用在图表的定义中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">      A--&gt;B[AAABBB];</span><br><span class="line">      B--&gt;D;</span><br><span class="line">      class A cssClass;</span><br></pre></td></tr></table></figure><p>默认样式类：当没有指定样式的时候，默认采用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classDef default fill:#f9f,stroke:#333,stroke-width:4px;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    classDef default fill:#f90,stroke:#555,stroke-width:4px;</span><br><span class="line">    id1(Start)--&gt;id2(Stop)</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LR    classDef default fill:#f90,stroke:#555,stroke-width:4px;    id1(Start)-->id2(Stop)</pre><h1 id="2-时序图-sequence-diagram"><a href="#2-时序图-sequence-diagram" class="headerlink" title="2 时序图(sequence diagram)"></a>2 时序图(sequence diagram)</h1><h2 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h2><p>时序图，又叫序列图，为uml中比较常用的图形，在md中如下制作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">　　Alice-&gt;&gt;John: Hello John, how are you ?</span><br><span class="line">　　John--&gt;&gt;Alice: Great!</span><br><span class="line">　　Alice-&gt;&gt;John: Huang,you are better .</span><br><span class="line">　　John--&gt;&gt;Alice: yeah, Just not bad.</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram　　Alice->>John: Hello John, how are you ?　　John-->>Alice: Great!　　Alice->>John: Huang,you are better .　　John-->>Alice: yeah, Just not bad.</pre><p>观察上图，如果想让John出现在前面，让Alice在后面，原图的结构不发生改变，那要如何操作。mermaid通过设定参与者(participants)的顺序控制二者的顺序，示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">　　participant John</span><br><span class="line">　　participant Alice</span><br><span class="line">　　Alice-xJohn:Hello John,how are you?</span><br><span class="line">　　John--&gt;&gt;Alice:Great!</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram　　participant John　　participant Alice　　Alice-xJohn:Hello John,how are you?　　John-->>Alice:Great!</pre><h2 id="2-2-消息语法"><a href="#2-2-消息语法" class="headerlink" title="2.2 消息语法"></a>2.2 消息语法</h2><p>实线或者虚线的使用，Arrow的六种样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br><span class="line">--&gt;</span><br><span class="line">-&gt;&gt;</span><br><span class="line">--&gt;&gt;</span><br><span class="line">-x</span><br><span class="line">--x</span><br></pre></td></tr></table></figure><p>具体示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you ?</span><br><span class="line">    John--&gt;Alice:Great!</span><br><span class="line">    Alice-&gt;&gt;John: dont borther me !</span><br><span class="line">    John--&gt;&gt;Alice:Great!</span><br><span class="line">    Alice-xJohn: wait!</span><br><span class="line">    John--xAlice: Ok!</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Alice->John: Hello John, how are you ?    John-->Alice:Great!    Alice->>John: dont borther me !    John-->>Alice:Great!    Alice-xJohn: wait!    John--xAlice: Ok!</pre><h2 id="2-3-便签"><a href="#2-3-便签" class="headerlink" title="2.3 便签"></a>2.3 便签</h2><p>序列图增加便签，具体规则<code>[right of | left of | over][Actor]:Text</code> ，具体示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">　　participant John</span><br><span class="line">　　Note left of John: Text in note</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram　　participant John　　Note left of John: Text in note</pre><p>跨越两个Actor的便签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Alice-&gt;&gt;John:Hello John, how are you?</span><br><span class="line">Note over Alice,John:A typical interaction</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Alice->>John:Hello John, how are you?    Note over Alice,John:A typical interaction</pre><h2 id="2-4-循环Loops"><a href="#2-4-循环Loops" class="headerlink" title="2.4 循环Loops"></a>2.4 循环Loops</h2><p>在序列图中，也可以使用循环，具体规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop Loop text</span><br><span class="line">... statements...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">　　Alice-&gt;&gt;John: Hello!</span><br><span class="line">　　loop Reply every minute</span><br><span class="line">　　　　John-&gt;&gt;Alice:Great!</span><br><span class="line">　　end</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram　　Alice->>John: Hello!　　loop Reply every minute　　　　John->>Alice:Great!　　end</pre><h2 id="2-5-选择ALT"><a href="#2-5-选择ALT" class="headerlink" title="2.5 选择ALT"></a>2.5 选择ALT</h2><p>在序列图中选择的表达。规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alt Describing text</span><br><span class="line">...statements...</span><br><span class="line">else</span><br><span class="line">...statements...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>或者使用opt(推荐在没有else的情况下使用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opt Describing text</span><br><span class="line">...statements...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">　　Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">　　alt is sick</span><br><span class="line">　　　　Bob-&gt;&gt;Alice:not so good :(</span><br><span class="line">　　else is well</span><br><span class="line">　　　　Bob-&gt;&gt;Alice:Feeling fresh like a daisy:)</span><br><span class="line">　　end</span><br><span class="line">　　opt Extra response</span><br><span class="line">　　　　Bob-&gt;&gt;Alice:Thanks for asking</span><br><span class="line">　　end</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram　　Alice->>Bob: Hello Bob, how are you?　　alt is sick　　　　Bob->>Alice:not so good :(　　else is well　　　　Bob->>Alice:Feeling fresh like a daisy:)　　end　　opt Extra response　　　　Bob->>Alice:Thanks for asking　　end</pre><h1 id="3-甘特图-gantt"><a href="#3-甘特图-gantt" class="headerlink" title="3 甘特图(gantt)"></a>3 甘特图(gantt)</h1><p>甘特图是一类条形图，由Karol Adamiechi在1896年提出, 而在1910年Henry Gantt也独立的提出了此种图形表示。通常用在对项目终端元素和总结元素的开始及完成时间进行的描述。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">section S1</span><br><span class="line">T1: 2014-01-01, 9d</span><br><span class="line"></span><br><span class="line">section S2</span><br><span class="line">T2: 2014-01-11, 9d</span><br><span class="line"></span><br><span class="line">section S3</span><br><span class="line">T3: 2014-01-02, 9d</span><br><span class="line">gantt</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">section S1</span><br><span class="line">T1: 2014-01-01, 9d</span><br><span class="line">section S2</span><br><span class="line">T2: 2014-01-11, 9d</span><br><span class="line">section S3</span><br><span class="line">T3: 2014-01-02, 9d</span><br></pre></td></tr></table></figure><p>先来看一个的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">section A section</span><br><span class="line">Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">Future task               :         des3, after des2, 5d</span><br><span class="line">Future task2               :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">section Critical tasks</span><br><span class="line">Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">Create tests for parser             :crit, active, 3d</span><br><span class="line">Future task in critical line        :crit, 5d</span><br><span class="line">Create tests for renderer           :2d</span><br><span class="line">Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">section Documentation</span><br><span class="line">Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">section Last section</span><br><span class="line">Describe gantt syntax               :after doc1, 3d</span><br><span class="line">Add gantt diagram to demo page      : 20h</span><br><span class="line">Add another diagram to demo page    : 48h</span><br></pre></td></tr></table></figure><pre class="mermaid">gantt    dateFormat  YYYY-MM-DD    title Adding GANTT diagram functionality to mermaid    section A section    Completed task            :done,    des1, 2014-01-06,2014-01-08    Active task               :active,  des2, 2014-01-09, 3d    Future task               :         des3, after des2, 5d    Future task2               :         des4, after des3, 5d    section Critical tasks    Completed task in the critical line :crit, done, 2014-01-06,24h    Implement parser and jison          :crit, done, after des1, 2d    Create tests for parser             :crit, active, 3d    Future task in critical line        :crit, 5d    Create tests for renderer           :2d    Add to mermaid                      :1d    section Documentation    Describe gantt syntax               :active, a1, after des1, 3d    Add gantt diagram to demo page      :after a1  , 20h    Add another diagram to demo page    :doc1, after a1  , 48h    section Last section    Describe gantt syntax               :after doc1, 3d    Add gantt diagram to demo page      : 20h    Add another diagram to demo page    : 48h</pre><p>具体关键字中英对应表。</p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>标题</td></tr><tr><td>dateFormat</td><td>日期格式</td></tr><tr><td>section</td><td>模块</td></tr><tr><td>Completed</td><td>已经完成</td></tr><tr><td>Active</td><td>当前正在进行</td></tr><tr><td>Future</td><td>后续待处理</td></tr><tr><td>crit</td><td>关键阶段</td></tr><tr><td>日期缺失</td><td>默认从上一项完成后</td></tr></tbody></table><p>关于日期的格式可以参考：  <a href="http://momentjs.com/docs/#/parsing/string-format/">string-format</a>    <a href="https://github.com/mbostock/d3/wiki/Time-Formatting">Time-Formatting</a></p><h1 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4 Demo"></a>4 Demo</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    sq[Square shape] --&gt; ci((Circle shape))</span><br><span class="line"></span><br><span class="line">    subgraph A subgraph</span><br><span class="line">        di&#123;Diamond with  line break&#125; -.-&gt; ro(Rounded)</span><br><span class="line">        di==&gt;ro2(Rounded square shape)</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    e --&gt; od3&gt;Really long text with linebreak&lt;br&gt;in an Odd shape]</span><br><span class="line"></span><br><span class="line">    cyr[Cyrillic]--&gt;cyr2((Circle shape Начало));</span><br><span class="line"></span><br><span class="line">    classDef green fill:#9f6,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef orange fill:#f96,stroke:#333,stroke-width:4px;</span><br><span class="line">    class sq,e green</span><br><span class="line">    class di orange</span><br></pre></td></tr></table></figure><pre class="mermaid">graph TB    sq[Square shape] --> ci((Circle shape))    subgraph A subgraph        di{Diamond with  line break} -.-> ro(Rounded)        di==>ro2(Rounded square shape)    end    e --> od3>Really long text with linebreak<br>in an Odd shape]    cyr[Cyrillic]-->cyr2((Circle shape Начало));    classDef green fill:#9f6,stroke:#333,stroke-width:2px;    classDef orange fill:#f96,stroke:#333,stroke-width:4px;    class sq,e green    class di orange</pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>markdown中所有图形的绘制最终其实都是在使用mermaid，该插件的具体官方地址为<a href="https://mermaidjs.github.io/">mermaidis</a>，本文中没有涵盖的需求具体可以在该链接中找到，总结来说这个绘图功能还是很强大的，在写这篇博客的过程中有一个很深的感触，就是你自己认为的一个很特别或者是小众的需求，其实很多的前辈们早就在之前已经想到、做过或者已经给出了完美的解决方案，所有平时没事的时候还是要多接触、多了解、多积累，等到真正使用的时候才不至于<strong>抓狂</strong>。</p><div class="note primary">            <h4 id="本文作者：tongtong"><a href="#本文作者：tongtong" class="headerlink" title="本文作者：tongtong"></a>本文作者：tongtong</h4><h4 id="本文链接：https-stongtong-github-io"><a href="#本文链接：https-stongtong-github-io" class="headerlink" title="本文链接：https://stongtong.github.io/"></a>本文链接：<a href="https://stongtong.github.io/">https://stongtong.github.io/</a></h4><h4 id="版权申明：网站内容为tongtong所有，转载请注明出处。"><a href="#版权申明：网站内容为tongtong所有，转载请注明出处。" class="headerlink" title="版权申明：网站内容为tongtong所有，转载请注明出处。"></a>版权申明：网站内容为tongtong所有，转载请注明出处。</h4>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;一直在用七牛云作为博客的图床，但是之前发现在七牛云的图床网址必须要进行备案了，太委屈！我自己的个人网站，就是在写写自己的日记、技术笔记、工作感悟、巴拉巴拉巴拉，还要让我备案，真是没地说理去；辗转反侧，也不能因为这个事情不写、不记录啊，所以最近萌生了博客无图的想法，之前用markdown的时候正好接触过markdown的绘图功能，身材很好（轻量级）并且该有的都有，哈哈，今天用这篇博客记录一下markdown中的常用绘图语法，方便以后使用。&lt;/p&gt;
    
    </summary>
    
      <category term="markdown" scheme="https://tongfan.xyz/categories/markdown/"/>
    
    
      <category term="markdown，mermaid" scheme="https://tongfan.xyz/tags/markdown%EF%BC%8Cmermaid/"/>
    
  </entry>
  
  <entry>
    <title>HBASE中LSM Tree</title>
    <link href="https://tongfan.xyz/2017/04/05/hbase01-LSM%20Tree/"/>
    <id>https://tongfan.xyz/2017/04/05/hbase01-LSM Tree/</id>
    <published>2017-04-05T02:30:44.000Z</published>
    <updated>2019-02-17T11:00:00.615Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>： HBASE最为出色的功能就是大数据量的写入性能，今天要介绍的就是HBASE中核心的数据结构LSM Tree，该数据结构保证了HBASE的数据写入的性能，废话不多说，开始正文。</p><a id="more"></a><h1 id="1-LSM-Tree由来"><a href="#1-LSM-Tree由来" class="headerlink" title="1 LSM Tree由来"></a>1 LSM Tree由来</h1><p>​    LSM Tree，全称<strong>Log-structured merge-tree</strong>，讲LSM树之前，需要提下三种基本的存储引擎，这样才能清楚LSM树的由来。</p><h2 id="（1）哈希存储引擎"><a href="#（1）哈希存储引擎" class="headerlink" title="（1）哈希存储引擎"></a>（1）哈希存储引擎</h2><p>​    哈希存储引擎，就是以哈希表为基础持久化实现，支持增、删、改以及随机读取操作，<strong>但不支持顺序扫描</strong>，对应的存储系统为key-value存储系统。对于key-value的插入、查询、删除操作，哈希表的复杂度都是O(1)；但如果在需求中需要进行顺序扫描或者范围查找，hash并不能够支持。</p><h2 id="（2）B树存储引擎"><a href="#（2）B树存储引擎" class="headerlink" title="（2）B树存储引擎"></a>（2）B树存储引擎</h2><p>​    B树存储引擎是以B树（一般都是B+树）的持久化实现，该种数据结构不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（下面有详细的解释），这里对B树、B+树进行简单的复习。</p><p>​    走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见，下面引用其文章中的话。</p><blockquote><p>​    “B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。“</p></blockquote><blockquote><p><strong>为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据库索引</strong>？</p></blockquote><blockquote><p>（1) B+ tree的磁盘读写代价更低<br>     B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>​    举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p><p>（2）B+tree的查询效率更加稳定<br>​     由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p>（3）B+ 树在顺序查询方面更加优秀</p><p>​    B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</p></blockquote><blockquote><p><strong>任何一种数据结构都是针对特定场景的，B+树也不例外，其缺点为：</strong></p></blockquote><blockquote><p>​    B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</p><p>​    从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）</p></blockquote><h2 id="（3）LSM树"><a href="#（3）LSM树" class="headerlink" title="（3）LSM树"></a>（3）LSM树</h2><p>​    LSM树存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且其通过批量存储技术，规避磁盘随机写入问题，但同时带来的问题就是<strong>LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</strong></p><p>​    下面将对LSM tree进行详细介绍。</p><h1 id="2-LSM-Tree原理"><a href="#2-LSM-Tree原理" class="headerlink" title="2 LSM Tree原理"></a>2 LSM Tree原理</h1><h2 id="2-1-设计思想"><a href="#2-1-设计思想" class="headerlink" title="2.1 设计思想"></a>2.1 设计思想</h2><p>​    LSM树的设计思想非常朴素，简而言之就是<strong>将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘</strong>，其具体做法是把一棵大树拆分成N棵小树，它首先将内容写入内存中，随着小树越来越大，当达到内存写入阈值后，内存中的小树会flush到磁盘中，这样磁盘中的树定期做merge操作，合并成一棵稳定的大树（<strong>优化数据的读性能</strong>）。当进行数据读取时，需要合并磁盘中历史数据和内存中最近修改操作，综合两者才能进行完整的数据查找操作。</p><p>​    批量操作减少了磁盘磁臂的移动次数降低了进行数据插入时磁盘磁臂的开销，所以写入性能大大提升，同时读性能有所下降，LSM在进行需要即时响应的操作时会损失I/O效率，最适用于索引插入比查询操作多的情况。</p><h2 id="2-2-详细说明"><a href="#2-2-详细说明" class="headerlink" title="2.2 详细说明"></a>2.2 详细说明</h2><p>​    LSM-Tree主题思想为划分成不同等级的树。可以想象一份索引由两棵树组成：一个存在于内存（可以使其他树结构），一个存在于磁盘（如下图）。</p><p><img src="https://i.loli.net/2019/02/17/5c693e36000ee.png" alt></p><p>​    数据首先会插入到内存中的树，为了防止数据丢失，写内存的同时需要暂时持久化到磁盘即输入数据时数据会以完全有序的形式先存储在日志文件中（对应HBase的MemStore和HLog）。当日志文件被修改时，对应的更新会被先保存在内存中来加速查询。</p><p>​    当内存中树的数据达到阈值时，会进行合并操作。合并操作会从左至右遍历内存中的叶子节点与磁盘中树的叶子节点进行合并，当合并的数据量达到磁盘的存储页的大小时，会将合并的数据持久化到磁盘。同时更新父亲节点对叶子节点的指针（如下图）。     </p><p><img src="https://i.loli.net/2019/02/17/5c693e38cd05d.png" alt="lsm11"></p><p>​    之前存在于磁盘的叶子节点被合并后，这些数据并不会被删除，这些数据会复制一份并与内存中的数据一起顺序写到磁盘。查找通过合并的方式完成，首先搜索内存存储结构，接下来是磁盘存储结构。</p><p>​    LSM树所有节点都是满的并按页存储，经过多次的flush会创建很多数据存储文件，后台线程会将小文件聚合成大文件，因此磁盘的寻道操作就会被限制在一定数目的数据存储文件中，以优化读性能。磁盘上的树结构也可以分割成多个存储文件，因为所有的存储数据都是按照Key有序排列的，因此在现有节点中插入新的关键字不需要重新排序。</p><p>​    LSM-Tree属于传输型，在磁盘传输速率上进行文件的排序和合并以及日志操作，可以更好的拓展到更大的数据规模上，因为它会使用日志文件和一个内存存储结构把随机写操作转化为顺序写，读写独立，不会产生两种操作的竞争。 </p><h1 id="3-hbase中的LSM-tree"><a href="#3-hbase中的LSM-tree" class="headerlink" title="3 hbase中的LSM-tree"></a>3 hbase中的LSM-tree</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>HBASE中，数据会先写到内存中，为了防止内存数据丢失，写内存的同时需要持久化到磁盘，对应了HBase的MemStore和HLog（即HBASE中wal，write ahead log）。</p><p>​    MemStore中的数据达到一定的阈值之后，需要将数据刷写到磁盘，即生成HFile（也是一颗小的B+树）文件。</p><p>​    hbase中的minor merge（少量HFile小文件合并）、 major merge（一个region的所有HFile文件合并，可能包括数据删除操作）执行compact操作，同时删除无效数据（过期及删除的数据），多棵小树在这个时机合并成大树，来增强（稳定）读性能。</p><p>​    hbase在实现中，是把整个内存数据达到一定阈值后，flush到disk中，形成一个file，这个file的存储也就是一个小的B+树，因为hbase一般是部署在hdfs上，hdfs不支持对文件的update操作，所以hbase是这样全部内存flush，而不是和磁盘中的小树merge update，这个设计也就能讲通了。内存flush到磁盘上的小树，定期也会合并成一个大树。整体上hbase就是用了lsm tree的思路。</p><h2 id="3-2-优化"><a href="#3-2-优化" class="headerlink" title="3.2 优化"></a>3.2 优化</h2><p><strong>针对LSM树读性能hbase的优化：</strong></p><p>​    <strong>Bloom-filter</strong>:就是个带随机概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定的数据。于是就可以不用二分查找，而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到提升，但付出空间代价。</p><p>​    <strong>compact</strong>：小树合并为大树，因为小树性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的老数据查询也可以直接使用log2N的方式找到，不需要再进行(N/m)*log2n的查询了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    HBASE中主要使用LSM-Tree来保证大量写入操作的性能，现在对HBASE的定位也主要集中在数据仓库的角色，存放海量数据，因此其写入需求远大于读取需求；任何一种数据库或者是一种组件，只是针对某些特定场景而存在，不可能针对所有的场景都是适合的，所以在进行技术选型或者产品定位时，在这一方面多考虑一点是特别重要的。</p><div class="note primary">            <h4 id="本文作者：tongtong"><a href="#本文作者：tongtong" class="headerlink" title="本文作者：tongtong"></a>本文作者：tongtong</h4><h4 id="本文链接：https-stongtong-github-io"><a href="#本文链接：https-stongtong-github-io" class="headerlink" title="本文链接：https://stongtong.github.io/"></a>本文链接：<a href="https://stongtong.github.io/">https://stongtong.github.io/</a></h4><h4 id="版权申明：网站内容为tongtong所有，转载请注明出处。"><a href="#版权申明：网站内容为tongtong所有，转载请注明出处。" class="headerlink" title="版权申明：网站内容为tongtong所有，转载请注明出处。"></a>版权申明：网站内容为tongtong所有，转载请注明出处。</h4>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;： HBASE最为出色的功能就是大数据量的写入性能，今天要介绍的就是HBASE中核心的数据结构LSM Tree，该数据结构保证了HBASE的数据写入的性能，废话不多说，开始正文。&lt;/p&gt;
    
    </summary>
    
      <category term="Hbase" scheme="https://tongfan.xyz/categories/Hbase/"/>
    
    
      <category term="LSM Tree" scheme="https://tongfan.xyz/tags/LSM-Tree/"/>
    
      <category term="Hbase" scheme="https://tongfan.xyz/tags/Hbase/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令记录</title>
    <link href="https://tongfan.xyz/2016/08/30/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://tongfan.xyz/2016/08/30/Hexo常用命令记录/</id>
    <published>2016-08-30T08:52:43.000Z</published>
    <updated>2018-11-11T02:20:13.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; //新建文章</span><br><span class="line">hexo new page &quot;我的类别&quot;  //新建目录下的page</span><br><span class="line">hexo p == hexo publish    //发布草稿到站点,其用法为hexo publish [layout] &lt;title&gt;</span><br><span class="line">hexo g == hexo generate  //生成</span><br><span class="line">hexo s == hexo server  //启动服务，当端口冲突时，其可以使用参数p更改端口，具体用法为hexo s -p 端口号</span><br><span class="line">hexo d == hexo deploy  //部署</span><br><span class="line">hexo c == hexo clean  //清楚生成文件</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="hexo中使用模板"><a href="#hexo中使用模板" class="headerlink" title="hexo中使用模板"></a>hexo中使用模板</h3><p>在hexo根目录下的scaffolds文件下，有生成创建文章的模板，在生成时，可以进行模板指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new photo &quot;My Gallery&quot;  //photo为指定模板，创建时其会到scaffolds文件下查找photo.md文件，进行相册的创建。</span><br></pre></td></tr></table></figure></p><h3 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">layout: 布局，默认为post</span><br><span class="line">title: 文章名称</span><br><span class="line">date: 创建时间</span><br><span class="line">updated: 修改时间</span><br><span class="line">comments: 评论开关</span><br><span class="line">tags: 标签</span><br><span class="line">categories: 类别</span><br><span class="line">permalink: 永久链接</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>基本就是这么多了，以后用到在继续添加。<br><div class="note primary">            <h4 id="本文作者：tongtong"><a href="#本文作者：tongtong" class="headerlink" title="本文作者：tongtong"></a>本文作者：tongtong</h4><h4 id="本文链接：https-stongtong-github-io"><a href="#本文链接：https-stongtong-github-io" class="headerlink" title="本文链接：https://stongtong.github.io/"></a>本文链接：<a href="https://stongtong.github.io/">https://stongtong.github.io/</a></h4><h4 id="版权申明：网站内容为tongtong所有，转载请注明出处。"><a href="#版权申明：网站内容为tongtong所有，转载请注明出处。" class="headerlink" title="版权申明：网站内容为tongtong所有，转载请注明出处。"></a>版权申明：网站内容为tongtong所有，转载请注明出处。</h4>          </div></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简写&quot;&gt;&lt;a href=&quot;#简写&quot; class=&quot;headerlink&quot; title=&quot;简写&quot;&gt;&lt;/a&gt;简写&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo n &amp;quot;我的博客&amp;quot; == hexo new &amp;quot;我的博客&amp;quot; //新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new page &amp;quot;我的类别&amp;quot;  //新建目录下的page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo p == hexo publish    //发布草稿到站点,其用法为hexo publish [layout] &amp;lt;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g == hexo generate  //生成&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo s == hexo server  //启动服务，当端口冲突时，其可以使用参数p更改端口，具体用法为hexo s -p 端口号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d == hexo deploy  //部署&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo c == hexo clean  //清楚生成文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="note" scheme="https://tongfan.xyz/categories/note/"/>
    
    
      <category term="Hexo" scheme="https://tongfan.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>github搭建各站记录</title>
    <link href="https://tongfan.xyz/2015/08/29/GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AE%B0%E5%BD%95/"/>
    <id>https://tongfan.xyz/2015/08/29/GitHub搭建个人网站记录/</id>
    <published>2015-08-29T08:52:43.000Z</published>
    <updated>2019-02-20T14:26:28.278Z</updated>
    
    <content type="html"><![CDATA[<p>本次搭建主要使用hexo，安装主题为next主题，包括站内搜索、站点、RSS、还有统计和评论系统，并实现 blog自动发布完成。</p><a id="more"></a><h1 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h1><p>1、下载node js和git，安装完成后，在node js中利用npm进行hexo的安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>2、在指定目录下初始化hexo目录， </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo ini hexo</span><br><span class="line">cd hexo</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这里的目录名称为hexo,将以上软件安装好之后，将原hexo文件夹下的文件目录统一存放在新建的hexo文件下即可，基本的框架搭建完成。</p><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>1、设置语言配置，主要在主题的目录下，查看language目录的支持的语言，之前next主题的中文语言文件为zh-Hans，但现在改成了zh-CN，这个一定要注意，要不然配置不会生效。</p><p>2、社交配置和支持的页面目录配置，这一部分主要是根据自己的需要 ，在主题配置文件中进行相应的指定，比较简单，需要说明的是，在指定图标的时候是在链接的后面用英文指定，next图标库支持600+图标这个能很好的满足；放开相关页面目录的配置，一定要新建目录页，比如categories，需要用<code>hexo new page</code>来创建这个页面，要不然会报错。</p><h1 id="部署功能"><a href="#部署功能" class="headerlink" title="部署功能"></a>部署功能</h1><p>要将写好的文件进行部署，需要安装插件，安装步骤为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装完毕使用hexo d命令进行部署。</p><h1 id="RSS功能和mapsite功能"><a href="#RSS功能和mapsite功能" class="headerlink" title="RSS功能和mapsite功能"></a>RSS功能和mapsite功能</h1><p>进行Rss功能扩展需要安装插件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>安装完毕后，会在hexo目录中出现node_modules文件夹，然后需要在hexo配置文件和主题配置文件中进行配置如下：<br>1、hexo配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br></pre></td></tr></table></figure><p>2、主题配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure><p>然后重启博客，在生成文件时，就会产生atom.xml文件，显示安装成功。<br>安装百度map-site功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-mapsite --save</span><br></pre></td></tr></table></figure></p><p>1、在hexo配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>2、在主题配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sitemap: /baidusitemap.xml</span><br></pre></td></tr></table></figure></p><p>重启博客后，点击查看。(npm install hexo-baidu-url-push –save)</p><h1 id="自定义站点搜索"><a href="#自定义站点搜索" class="headerlink" title="自定义站点搜索"></a>自定义站点搜索</h1><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p><p>1、在hexo配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><p>2、在主题文件中配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p><h1 id="配置分类和标签"><a href="#配置分类和标签" class="headerlink" title="配置分类和标签"></a>配置分类和标签</h1><p>next主题中的分类和标签要通过新建index文件来产生。具体操作如下<br>运行 hexo new page tags 命令后会产生 source/tags/index.md 这个文件，你要修改这个文件，在里面添加一句话type: “tags”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title: &quot;tags&quot;</span><br><span class="line">date: 2015-03-24 08:58:02</span><br></pre></td></tr></table></figure></p><p>添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure></p><p>然后运行服务器即可访问tags页面了。</p><p>在 2015-05-29 06:22:57，”Leon Lin” <a href="mailto:notifications@github.com">notifications@github.com</a> 写道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cd path/to/hexo</span><br><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page categories</span><br><span class="line">$ vim source/tags/index.md</span><br><span class="line"></span><br><span class="line">add line: type: &quot;tags&quot;</span><br><span class="line"></span><br><span class="line">$ vim source/categories/index.md</span><br><span class="line"></span><br><span class="line">add line: type: &quot;categories&quot;</span><br><span class="line"></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure></p><p>做完之後產生的 /tags/index.html 裡面沒有顯示出所用的tag…</p><h1 id="valine评论"><a href="#valine评论" class="headerlink" title="valine评论"></a>valine评论</h1><p>next主题支持多说、友言、畅言、来必力等评论系统，这里说一下，多说已经与17年6月关闭了自己的评论系统，原因估计是不赚钱，友言的评论系统很是难用这里也不多说了，畅言系统要求必须要有国内的ICP备案号，这一点比较坑，自己搭个各站，还要去备案，太过复杂，这里就只剩下来必力了，不过这几种，我都有尝试，尝试下来感觉都不太好，前段时间看到了一个基于LeanCloud的全新的评论系统valine，总结一个词就是<strong><em>好用</em></strong>，所以这里极力推荐使用valine作为评论系统，具体配置也很简单，基本你看了主题的这部分配置项就会明白，和阅读统计基本上差不多。</p><h1 id="添加阅读统计"><a href="#添加阅读统计" class="headerlink" title="添加阅读统计"></a>添加阅读统计</h1><p>在LeanCloud注册账号，创建应用并制定Counter，然后获取AppId和App key在主题配置文件中指定，需要注意的是，这里需要对创建的计数进行安全限制，相关操作hexo论坛有很多，这里不再说明。</p><p>在leancloud上注册账号，本账号具体为<br><img src="http://i.imgur.com/t9Aex4E.png" alt></p><p>然后新建一个应用，应用的名称可以随便选取，在该应用中新建一个class，class权限设置为最大，class名称为Counter，然后进入设置，可以获取ID和Key，</p><p>获取之后，在主题配置文件中进行设定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: C5p</span><br><span class="line">  app_key: iD</span><br></pre></td></tr></table></figure></p><p>重启blog即可。</p><div class="note primary">            <h4 id="本文作者：tongtong"><a href="#本文作者：tongtong" class="headerlink" title="本文作者：tongtong"></a>本文作者：tongtong</h4><h4 id="本文链接：https-stongtong-github-io"><a href="#本文链接：https-stongtong-github-io" class="headerlink" title="本文链接：https://stongtong.github.io/"></a>本文链接：<a href="https://stongtong.github.io/">https://stongtong.github.io/</a></h4><h4 id="版权申明：网站内容为tongtong所有，转载请注明出处。"><a href="#版权申明：网站内容为tongtong所有，转载请注明出处。" class="headerlink" title="版权申明：网站内容为tongtong所有，转载请注明出处。"></a>版权申明：网站内容为tongtong所有，转载请注明出处。</h4>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次搭建主要使用hexo，安装主题为next主题，包括站内搜索、站点、RSS、还有统计和评论系统，并实现 blog自动发布完成。&lt;/p&gt;
    
    </summary>
    
      <category term="next" scheme="https://tongfan.xyz/categories/next/"/>
    
    
      <category term="github" scheme="https://tongfan.xyz/tags/github/"/>
    
      <category term="person" scheme="https://tongfan.xyz/tags/person/"/>
    
  </entry>
  
  <entry>
    <title>Next主题内置标签</title>
    <link href="https://tongfan.xyz/2015/03/23/Next%E4%B8%BB%E9%A2%98%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE/"/>
    <id>https://tongfan.xyz/2015/03/23/Next主题内置标签/</id>
    <published>2015-03-23T11:23:49.000Z</published>
    <updated>2019-02-12T11:13:46.496Z</updated>
    
    <content type="html"><![CDATA[<p>该文章测试next主题中的图片表示，因为看到官网上有很多的内置标签，测试一下，方便以后使用。</p><a id="more"></a><h3 id="字体居中"><a href="#字体居中" class="headerlink" title="字体居中"></a>字体居中</h3><h4 id="HTML方式"><a href="#HTML方式" class="headerlink" title="HTML方式"></a>HTML方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;该部分为文字居中&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure><p><blockquote class="blockquote-center">该部分为文字居中</blockquote></p><h4 id="内置标签方式"><a href="#内置标签方式" class="headerlink" title="内置标签方式"></a>内置标签方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><p>居中文字标签模式</p></blockquote><p>标签简写模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure></p><h3 id="突破宽度限制图片"><a href="#突破宽度限制图片" class="headerlink" title="突破宽度限制图片"></a>突破宽度限制图片</h3><p>当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。 此标签有两种调用方式（详细参看底下示例）：</p><h4 id="HTML方式：使用这种方式时，为-img-添加属性-class-”full-image”即可。"><a href="#HTML方式：使用这种方式时，为-img-添加属性-class-”full-image”即可。" class="headerlink" title="HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。"></a>HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/drFzc4r.jpg" class="full-image"><br><!-- more --></p><h4 id="标签方式：使用-fullimage-或者-简写-fi，-并传递图片地址、-alt-和-title-属性即可。-属性之间以逗号分隔。"><a href="#标签方式：使用-fullimage-或者-简写-fi，-并传递图片地址、-alt-和-title-属性即可。-属性之间以逗号分隔。" class="headerlink" title="标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。"></a>标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% fullimage /image-url, alt, title %&#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://i.imgur.com/drFzc4r.jpg" class="full-image" alt="这里是alt" title="这是图片名称"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>可以简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 别名 --&gt;</span><br><span class="line">&#123;% fi /image-url, alt, title %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="这里是markdown自带的显示："><a href="#这里是markdown自带的显示：" class="headerlink" title="这里是markdown自带的显示："></a>这里是markdown自带的显示：</h4><p><img src="http://i.imgur.com/drFzc4r.jpg" alt="图片名称显示在哪"></p><p>以上三种比较，很是明显。</p><h3 id="bootstrap-callout"><a href="#bootstrap-callout" class="headerlink" title="bootstrap callout"></a>bootstrap callout</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>其中，class_name 可以是以下列表中的一个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">primary</span><br><span class="line">success</span><br><span class="line">info</span><br><span class="line">warning</span><br><span class="line">danger</span><br></pre></td></tr></table></figure></p><h4 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h4><div class="note default">            <p>此类别为default </p>          </div><div class="note primary">            <p>此类别为primary </p>          </div><div class="note success">            <p>此类别为success </p>          </div><div class="note info">            <p>此类别为info </p>          </div><div class="note warning">            <p>此类别为warning</p>          </div><div class="note danger">            <p>此类别为danger</p>          </div><div class="note primary">            <h4 id="本文作者：tongtong"><a href="#本文作者：tongtong" class="headerlink" title="本文作者：tongtong"></a>本文作者：tongtong</h4><h4 id="本文链接：https-stongtong-github-io"><a href="#本文链接：https-stongtong-github-io" class="headerlink" title="本文链接：https://stongtong.github.io/"></a>本文链接：<a href="https://stongtong.github.io/">https://stongtong.github.io/</a></h4><h4 id="版权申明：网站内容为tongtong所有，转载请注明出处。"><a href="#版权申明：网站内容为tongtong所有，转载请注明出处。" class="headerlink" title="版权申明：网站内容为tongtong所有，转载请注明出处。"></a>版权申明：网站内容为tongtong所有，转载请注明出处。</h4>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该文章测试next主题中的图片表示，因为看到官网上有很多的内置标签，测试一下，方便以后使用。&lt;/p&gt;
    
    </summary>
    
      <category term="next" scheme="https://tongfan.xyz/categories/next/"/>
    
    
      <category term="next" scheme="https://tongfan.xyz/tags/next/"/>
    
  </entry>
  
</feed>
